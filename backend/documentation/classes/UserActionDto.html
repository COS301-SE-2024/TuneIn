<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>tunein-backend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">tunein-backend documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">












<ol class="breadcrumb">
  <li class="breadcrumb-item">Classes</li>
  <li class="breadcrumb-item" >UserActionDto</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/modules/rooms/rooms.service.ts</code>
        </p>






            <section data-compodoc="block-index">
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier"></span>
                                    <span class="modifier"></span>
                                <a href="#userID" >userID</a>
                            </li>
                        </ul>
                    </td>
                </tr>






        </tbody>
    </table>
</section>


            <section data-compodoc="block-properties">
    
    <h3 id="inputs">
        Properties
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="userID"></a>
                    <span class="name">
                            <span class="modifier"></span>
                            <span class="modifier"></span>
                        <span ><b>userID</b></span>
                        <a href="#userID"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <b>Decorators : </b>
                        <br />
                        <code>
                            @ApiProperty({description: &#x27;The user ID of the user that the action was performed on&#x27;, type: &#x27;string&#x27;, example: &#x27;123e4567-e89b-12d3-a456-426614174000&#x27;, format: &#x27;uuid&#x27;})<br />@IsString()<br />
                        </code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="35" class="link-to-prism">src/modules/rooms/rooms.service.ts:35</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
</section>







    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { HttpException, HttpStatus, Injectable } from &quot;@nestjs/common&quot;;
import { RoomDto } from &quot;./dto/room.dto&quot;;
import { UpdateRoomDto } from &quot;./dto/updateroomdto&quot;;
import { UserDto } from &quot;../users/dto/user.dto&quot;;
import { PrismaService } from &quot;../../../prisma/prisma.service&quot;;
import * as PrismaTypes from &quot;@prisma/client&quot;;
import { Prisma } from &quot;@prisma/client&quot;;
import { DtoGenService } from &quot;../dto-gen/dto-gen.service&quot;;
import {
	DbUtilsService,
	FullyQualifiedRoom,
} from &quot;../db-utils/db-utils.service&quot;;
import { LiveChatMessageDto } from &quot;../../live/dto/livechatmessage.dto&quot;;
import { EmojiReactionDto } from &quot;../../live/dto/emojireaction.dto&quot;;
import { ApiProperty } from &quot;@nestjs/swagger&quot;;
import { IsString } from &quot;class-validator&quot;;
import { SpotifyService } from &quot;../../spotify/spotify.service&quot;;
import { RoomQueueService, ActiveRoom } from &quot;./roomqueue/roomqueue.service&quot;;
import { RoomSongDto } from &quot;./dto/roomsong.dto&quot;;
import { kmeans } from &quot;ml-kmeans&quot;;
import { KMeansResult } from &quot;ml-kmeans/lib/KMeansResult&quot;;
import * as Spotify from &quot;@spotify/web-api-ts-sdk&quot;;
import { Server } from &quot;socket.io&quot;;
import { DirectMessageDto } from &quot;../users/dto/dm.dto&quot;;
import { DmUsersService } from &quot;../../live/dmusers/dmusers.service&quot;;

export class UserActionDto {
	@ApiProperty({
		description: &quot;The user ID of the user that the action was performed on&quot;,
		type: &quot;string&quot;,
		example: &quot;123e4567-e89b-12d3-a456-426614174000&quot;,
		format: &quot;uuid&quot;,
	})
	@IsString()
	userID: string;
}

@Injectable()
export class RoomsService {
	// DUMBroomQueues: Map&lt;string, string&gt; &#x3D; new Map&lt;string, string&gt;();
	public server: Server | undefined;

	constructor(
		private readonly prisma: PrismaService,
		private readonly dtogen: DtoGenService,
		private readonly dbUtils: DbUtilsService,
		private readonly spotifyService: SpotifyService,
		private readonly roomQueueService: RoomQueueService,
		private readonly dmUsersService: DmUsersService,
	) {}

	async getNewRooms(limit &#x3D; -1): Promise&lt;RoomDto[]&gt; {
		const rooms: FullyQualifiedRoom[] &#x3D; await this.prisma.room.findMany({
			where: {
				NOT: {
					public_room: null,
				},
			},
			include: {
				child_room_child_room_parent_room_idToroom: true,
				participate: true,
				private_room: true,
				public_room: true,
				scheduled_room: true,
			},
			orderBy: {
				date_created: &quot;desc&quot;,
			},
		});
		if (rooms.length &#x3D;&#x3D;&#x3D; 0) {
			return [];
		}
		if (limit &gt; 0) {
			rooms.splice(limit);
		}
		return await this.dtogen.generateMultipleRoomDtoFromRoom(rooms);
	}

	async getRoomInfo(roomID: string): Promise&lt;RoomDto&gt; {
		console.log(&quot;Getting room info for room&quot;, roomID);
		const room: FullyQualifiedRoom | null &#x3D; await this.prisma.room.findFirst({
			where: {
				room_id: roomID,
			},
			include: {
				child_room_child_room_parent_room_idToroom: true,
				participate: true,
				private_room: true,
				public_room: true,
				scheduled_room: true,
			},
		});
		if (room &#x3D;&#x3D;&#x3D; null) {
			throw new Error(&quot;Room does not exist&quot;);
		}
		// filter out null values
		const rooms: RoomDto[] &#x3D; await this.dtogen.generateMultipleRoomDtoFromRoom([
			room,
		]);
		const result: RoomDto &#x3D; rooms[0];
		const currentSong: RoomSongDto | undefined &#x3D; await this.getCurrentSong(
			roomID,
		);
		if (currentSong) {
			result.current_song &#x3D; currentSong;
		}
		return result;
	}

	async getMultipleRoomInfo(roomIDs: string[]): Promise&lt;RoomDto[]&gt; {
		console.log(&quot;Getting room info for rooms&quot;, roomIDs);
		const rooms: FullyQualifiedRoom[] &#x3D;
			await this.dbUtils.getFullyQualifiedRooms(roomIDs);
		roomIDs.map((roomID) &#x3D;&gt; {
			if (!rooms.find((r) &#x3D;&gt; r.room_id &#x3D;&#x3D;&#x3D; roomID)) {
				throw new HttpException(
					&quot;Room with id &#x27;&quot; + roomID + &quot;&#x27; does not exist&quot;,
					HttpStatus.NOT_FOUND,
				);
			}
		});
		const result: RoomDto[] &#x3D; await this.dtogen.generateMultipleRoomDtoFromRoom(
			rooms,
		);
		const currentSongs: (RoomSongDto | undefined)[] &#x3D;
			this.getCurrentSongs(roomIDs);
		for (let i &#x3D; 0; i &lt; result.length; i++) {
			const c &#x3D; currentSongs[i];
			if (c) {
				result[i].current_song &#x3D; c;
			}
		}
		return result;
	}

	async updateRoomInfo(
		userID: string,
		roomID: string,
		updateRoomDto: UpdateRoomDto,
	): Promise&lt;RoomDto&gt; {
		if (!(await this.dbUtils.userExists(userID))) {
			throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		const r &#x3D; await this.prisma.room.findFirst({
			where: {
				room_id: roomID,
			},
			include: {
				private_room: true,
				public_room: true,
				scheduled_room: true,
			},
		});

		if (!r) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		if (r.room_creator !&#x3D;&#x3D; userID) {
			throw new HttpException(
				&quot;User is not the owner of the room&quot;,
				HttpStatus.FORBIDDEN,
			);
		}

		const updatedRoom: Prisma.roomUpdateInput &#x3D; {
			room_id: roomID,
		};

		if (updateRoomDto.room_name !&#x3D;&#x3D; undefined) {
			updatedRoom.name &#x3D; updateRoomDto.room_name;
		}

		if (updateRoomDto.description) {
			updatedRoom.description &#x3D; updateRoomDto.description;
		}

		if (updateRoomDto.room_image !&#x3D;&#x3D; undefined) {
			updatedRoom.playlist_photo &#x3D; updateRoomDto.room_image;
		}

		if (updateRoomDto.room_size !&#x3D;&#x3D; undefined) {
			updatedRoom.room_size &#x3D; updateRoomDto.room_size as unknown as number;
		}

		if (updateRoomDto.tags !&#x3D;&#x3D; undefined) {
			updatedRoom.tags &#x3D; updateRoomDto.tags;
		}

		if (updateRoomDto.has_explicit_content !&#x3D;&#x3D; undefined) {
			updatedRoom.explicit &#x3D; updateRoomDto.has_explicit_content;
		}

		if (updateRoomDto.has_nsfw_content !&#x3D;&#x3D; undefined) {
			updatedRoom.nsfw &#x3D; updateRoomDto.has_nsfw_content;
		}

		if (updateRoomDto.language) {
			updatedRoom.room_language &#x3D; updateRoomDto.language;
		}

		if (updateRoomDto.is_temporary !&#x3D;&#x3D; undefined) {
			updatedRoom.is_temporary &#x3D; updateRoomDto.is_temporary;
		}

		if (updateRoomDto.is_scheduled !&#x3D;&#x3D; undefined) {
			if (updateRoomDto.is_scheduled) {
				// update if the room already is a scheduled room, else create a new scheduled room
				updatedRoom.scheduled_room &#x3D; {
					upsert: {
						create: {
							start_date: updateRoomDto.start_date ?? null,
							end_date: updateRoomDto.end_date ?? null,
						},
						update: {
							start_date: updateRoomDto.start_date ?? null,
							end_date: updateRoomDto.end_date ?? null,
						},
					},
				};
			} else {
				if (r.scheduled_room) {
					updatedRoom.scheduled_room &#x3D; {
						delete: true,
					};
				}
			}
		}

		if (updateRoomDto.is_private !&#x3D;&#x3D; undefined) {
			if (updateRoomDto.is_private) {
				if (r.public_room) {
					updatedRoom.public_room &#x3D; {
						delete: true,
					};
				}
				updatedRoom.private_room &#x3D; {
					upsert: {
						create: {},
						update: {},
					},
				};
			} else {
				if (r.private_room) {
					updatedRoom.private_room &#x3D; {
						delete: true,
					};
				}
				updatedRoom.public_room &#x3D; {
					upsert: {
						create: {},
						update: {},
					},
				};
			}
		}

		try {
			const room: FullyQualifiedRoom &#x3D; await this.prisma.room.update({
				where: {
					room_id: roomID,
				},
				data: updatedRoom,
				include: {
					child_room_child_room_parent_room_idToroom: true,
					participate: true,
					private_room: true,
					public_room: true,
					scheduled_room: true,
				},
			});

			const rooms &#x3D; await this.dtogen.generateMultipleRoomDtoFromRoom([room]);
			return rooms[0];
		} catch (error) {
			console.error(&quot;Error updating room info:&quot;, error);
			throw error;
		}
	}

	async deleteRoom(room_id: string, room_creator: string): Promise&lt;boolean&gt; {
		// Check if the room exists
		// delete the room user is the owner
		let isDeleted &#x3D; false;
		try {
			await this.prisma.room
				.delete({
					where: { room_id, room_creator },
				})
				.then((room) &#x3D;&gt; {
					console.log(&quot;deleting&quot;, room);
					isDeleted &#x3D; true;
				});
			// console.log(isDeleted);
			return isDeleted;
		} catch (error) {
			return false;
		}
	}

	async joinRoom(_room_id: string, user_id: string): Promise&lt;void&gt; {
		console.log(&quot;user&quot;, user_id, &quot;joining room&quot;, _room_id);
		try {
			// check if room creator blocked the user
			const _room &#x3D; await this.prisma.room.findFirst({
				where: {
					room_id: _room_id,
				},
				include: {
					participate: true,
					banned: true,
				},
			});
			if (!_room || _room &#x3D;&#x3D;&#x3D; null) {
				throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
			}
			// check if room is at capacity
			if (_room.participate.length &gt;&#x3D; Number(_room.room_size)) {
				throw new HttpException(&quot;Room is at capacity&quot;, HttpStatus.FORBIDDEN);
			}

			if (_room.banned.find((banned) &#x3D;&gt; banned.user_id &#x3D;&#x3D;&#x3D; user_id)) {
				throw new HttpException(
					&quot;User is banned from joining the room&quot;,
					HttpStatus.FORBIDDEN,
				);
			}
			const blocked &#x3D; await this.prisma.blocked.findFirst({
				where: {
					blocker: _room.room_creator,
					blockee: user_id,
				},
			});
			if (blocked) {
				throw new HttpException(
					&quot;User is blocked from joining the room&quot;,
					HttpStatus.FORBIDDEN,
				);
			}

			// Check if the user is already in the room
			const room &#x3D; await this.prisma.participate.findFirst({
				where: {
					user_id: user_id,
				},
			});

			if (room) {
				await this.leaveRoom(room.room_id, user_id);
			}
			// Add the user to the room
			await this.prisma.participate.create({
				data: {
					room_id: _room_id,
					user_id: user_id,
				},
			});
			// add user to the user_activity table
			await this.prisma.user_activity.create({
				data: {
					room_id: _room_id,
					user_id: user_id,
					room_join_time: new Date(),
				},
			});
		} catch (error) {
			console.error(&quot;Error joining room:&quot;, error);
			throw error;
		}
	}

	async leaveRoom(room_id: string, user_id: string): Promise&lt;void&gt; {
		// TODO: Implement logic to leave room
		console.log(&quot;user&quot;, user_id, &quot;leaving room&quot;, room_id);
		try {
			// Check if the user is already in the room
			const room &#x3D; await this.prisma.participate.findFirst({
				where: {
					room_id: room_id,
					user_id: user_id,
				},
			});

			// If the user is already in the room, return false
			if (!room || room &#x3D;&#x3D;&#x3D; null) {
				throw new HttpException(
					&quot;User is not in the room&quot;,
					HttpStatus.NOT_FOUND,
				);
			}

			// Add the user to the room
			await this.prisma.participate.delete({
				where: {
					participate_id: room.participate_id,
				},
			});
			const user &#x3D; await this.prisma.user_activity.findFirst({
				where: {
					room_id: room_id,
					user_id: user_id,
					room_leave_time: null,
				},
			});
			if (!user || user &#x3D;&#x3D;&#x3D; null) {
				throw new HttpException(
					&quot;User is not in the room&quot;,
					HttpStatus.NOT_FOUND,
				);
			}
			// if the user has been successfully remove from the room, then update the room_leave_time to the user_activity table
			await this.prisma.user_activity.update({
				where: {
					activity_id: user.activity_id,
				},
				data: {
					room_leave_time: new Date(),
				},
			});
		} catch (error) {
			console.error(&quot;Error leaving room:&quot;, error);
			throw error;
		}
	}

	async getNumFollowers(
		user_id: string,
		getFollowers: boolean,
	): Promise&lt;number&gt; {
		try {
			const _where: object &#x3D; getFollowers
				? {
						follower: user_id,
				  }
				: {
						followee: user_id,
				  };
			const followers: number &#x3D; await this.prisma.follows.count({
				where: _where,
			});
			return followers;
		} catch (error) {
			return 0;
		}
	}

	async getRoomUsers(room_id: string): Promise&lt;UserDto[]&gt; {
		try {
			// write a query to get all the users in the room
			const users &#x3D; await this.prisma.participate.findMany({
				where: {
					room_id: room_id,
				},
				include: {
					users: true,
				},
			});

			// map all the users to the userdto
			console.log(&quot;Users in room&quot;, users);
			const ids: string[] &#x3D; users.map((user) &#x3D;&gt; user.user_id);
			const userDtos: UserDto[] &#x3D; await this.dtogen.generateMultipleUserDto(
				ids,
			);
			return userDtos;
		} catch (error) {
			console.error(&quot;Error getting room users:&quot;, error);
			return [];
		}
	}

	async getRoomUserCount(room_id: string): Promise&lt;number&gt; {
		try {
			const count &#x3D; await this.prisma.participate.count({
				where: {
					room_id: room_id,
				},
			});
			return count;
		} catch (error) {
			return -1;
		}
	}

	getRoomQueue(roomID: string): RoomSongDto[] {
		const room: ActiveRoom | undefined &#x3D;
			this.roomQueueService.roomQueues.get(roomID);
		if (!room) {
			//room is inactive
			return [];
		} else {
			return room.queueAsRoomSongDto();
		}
	}

	async getCurrentSong(roomID: string): Promise&lt;RoomSongDto | undefined&gt; {
		const queue: RoomSongDto[] &#x3D; await this.getRoomQueue(roomID);
		if (queue.length &#x3D;&#x3D;&#x3D; 0) {
			return undefined;
		}
		const result: RoomSongDto &#x3D; queue[0];
		return result;
	}

	getCurrentSongs(roomIDs: string[]): (RoomSongDto | undefined)[] {
		const queues: RoomSongDto[][] &#x3D; roomIDs.map((roomID) &#x3D;&gt; {
			return this.getRoomQueue(roomID);
		});
		return queues.map((queue) &#x3D;&gt; {
			if (queue.length &#x3D;&#x3D;&#x3D; 0) {
				return undefined;
			}
			return queue[0];
		});
	}

	async getLiveChatHistory(roomID: string): Promise&lt;PrismaTypes.message[]&gt; {
		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(
				&quot;Room with id &#x27;&quot; + roomID + &quot;&#x27; does not exist&quot;,
				HttpStatus.NOT_FOUND,
			);
		}

		const roomMessages: PrismaTypes.room_message[] &#x3D;
			await this.prisma.room_message.findMany({
				where: {
					room_id: roomID,
				},
			});

		if (roomMessages.length &#x3D;&#x3D;&#x3D; 0) {
			return [];
		}

		const ids: string[] &#x3D; [];
		for (const message of roomMessages) {
			ids.push(message.message_id);
		}

		const messages: PrismaTypes.message[] &#x3D; await this.prisma.message.findMany({
			where: {
				message_id: {
					in: ids,
				},
			},
		});

		if (messages.length &#x3D;&#x3D;&#x3D; 0) {
			throw new Error(
				&quot;Failed to get chat history (no messages found) matching IDs for room with id &#x27;&quot; +
					roomID +
					&quot;&#x27;. DB may be corrupted.&quot;,
			);
		}
		return messages;
	}

	async getLiveChatHistoryDto(roomID: string): Promise&lt;LiveChatMessageDto[]&gt; {
		const messages: PrismaTypes.message[] &#x3D; await this.getLiveChatHistory(
			roomID,
		);
		const result: LiveChatMessageDto[] &#x3D;
			await this.dtogen.generateMultipleLiveChatMessageDto(messages);
		return result;
	}

	async createMessage(message: Prisma.messageCreateInput): Promise&lt;string&gt; {
		const newMessage: PrismaTypes.message &#x3D; await this.prisma.message.create({
			data: message,
		});
		return newMessage.message_id;
	}

	async createLiveChatMessage(
		message: LiveChatMessageDto,
		userID?: string,
	): Promise&lt;string&gt; {
		if (!(await this.dbUtils.roomExists(message.roomID))) {
			throw new Error(&quot;Room with id &#x27;&quot; + message.roomID + &quot;&#x27; does not exist&quot;);
		}

		let u: string &#x3D; message.sender.userID;
		if (userID) {
			u &#x3D; userID;
		}
		const sender: PrismaTypes.users | null &#x3D; await this.prisma.users.findUnique(
			{
				where: {
					user_id: u,
				},
			},
		);

		if (sender &#x3D;&#x3D;&#x3D; null) {
			throw new Error(
				&quot;Failed to get user with id &#x27;&quot; +
					u +
					&quot;&#x27; and name &#x27;&quot; +
					message.sender.username +
					&quot;&#x27;&quot;,
			);
		}

		const newMessage: Prisma.messageCreateInput &#x3D; {
			contents: message.messageBody,
			users: {
				connect: {
					user_id: sender.user_id,
				},
			},
		};

		const messageID: string &#x3D; await this.createMessage(newMessage);

		const roomMessage: PrismaTypes.room_message | null &#x3D;
			await this.prisma.room_message.create({
				data: {
					room_id: message.roomID,
					message_id: messageID,
				},
			});

		if (roomMessage &#x3D;&#x3D;&#x3D; null) {
			throw new Error(
				&quot;Failed to create room message for room with id &#x27;&quot; +
					message.roomID +
					&quot;&#x27;. Unknown database error&quot;,
			);
		}
		return messageID;
	}

	async bookmarkRoom(roomID: string, userID: string): Promise&lt;void&gt; {
		if (!(await this.dbUtils.userExists(userID))) {
			throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		const existingBookmark: PrismaTypes.bookmark | null &#x3D;
			await this.prisma.bookmark.findFirst({
				where: {
					room_id: roomID,
					user_id: userID,
				},
			});

		if (existingBookmark) {
			throw new HttpException(
				&quot;User has already bookmarked this room&quot;,
				HttpStatus.CONFLICT,
			);
		}

		const b: Prisma.bookmarkCreateInput &#x3D; {
			users: {
				connect: {
					user_id: userID,
				},
			},
			room: {
				connect: {
					room_id: roomID,
				},
			},
		};
		const newBookmark: PrismaTypes.bookmark | null &#x3D;
			await this.prisma.bookmark.create({
				data: b,
			});
		if (newBookmark &#x3D;&#x3D;&#x3D; null) {
			throw new Error(
				&quot;Failed to bookmark room. Database returned null after insert.&quot;,
			);
		}
	}

	async unbookmarkRoom(roomID: string, userID: string): Promise&lt;void&gt; {
		if (!(await this.dbUtils.userExists(userID))) {
			throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		const existingBookmark: PrismaTypes.bookmark | null &#x3D;
			await this.prisma.bookmark.findFirst({
				where: {
					room_id: roomID,
					user_id: userID,
				},
			});
		if (!existingBookmark) {
			throw new HttpException(
				&quot;User has not bookmarked this room&quot;,
				HttpStatus.NOT_FOUND,
			);
		}

		const b: Prisma.bookmarkDeleteManyArgs &#x3D; {
			where: {
				room_id: roomID,
				user_id: userID,
			},
		};
		const delBookmark: Prisma.BatchPayload &#x3D;
			await this.prisma.bookmark.deleteMany(b);
		console.log(delBookmark);
	}

	async saveReaction(
		roomID: string,
		emojiReactionDto: EmojiReactionDto,
	): Promise&lt;void&gt; {
		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new Error(&quot;Room with id &#x27;&quot; + roomID + &quot;&#x27; does not exist&quot;);
		}

		const userID &#x3D; emojiReactionDto.userID;
		if (!(await this.dbUtils.userExists(userID))) {
			throw new Error(&quot;User with id &#x27;&quot; + userID + &quot;&#x27; does not exist&quot;);
		}

		const newReaction: PrismaTypes.chat_reactions | null &#x3D;
			await this.prisma.chat_reactions.create({
				data: {
					user_id: userID,
					room_id: roomID,
					reaction: emojiReactionDto.body,
				},
			});
		if (newReaction &#x3D;&#x3D;&#x3D; null) {
			throw new Error(
				&quot;Failed to save reaction. Database returned null after insert.&quot;,
			);
		}
	}

	async getKickedUsers(roomID: string): Promise&lt;UserDto[]&gt; {
		console.log(roomID);
		// Implement the logic to get the kicked users for the room
		// if (true) {
		// 	// room does not exist
		// 	throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		// }
		return [];
	}

	async kickUser(
		roomID: string,
		initiatorID: string,
		kickedUserID: string,
	): Promise&lt;void&gt; {
		console.log(roomID);
		console.log(initiatorID);
		console.log(kickedUserID);
		// Implement the logic to kick a user from the room
		if (true) {
			// room does not exist
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		// if (true) {
		// 	// user does not exist
		// 	throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		// }

		// if (true) {
		// 	// user does not have permission to kick
		// 	throw new HttpException(&quot;User is not in the room&quot;, HttpStatus.FORBIDDEN);
		// }

		// if (true) {
		// 	// user is not in the room
		// 	throw new HttpException(
		// 		&quot;User is not in the room&quot;,
		// 		HttpStatus.BAD_REQUEST,
		// 	);
		// }

		// if (true) {
		// 	// user is trying to kick themselves
		// 	throw new HttpException(&quot;User is the initiator&quot;, HttpStatus.BAD_REQUEST);
		// }
	}

	async undoKick(
		roomID: string,
		initiatorID: string,
		kickedUserID: string,
	): Promise&lt;void&gt; {
		console.log(roomID);
		console.log(initiatorID);
		console.log(kickedUserID);
		// Implement the logic to undo the kick of a participant in the room
		if (true) {
			// room does not exist
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}

		// if (true) {
		// 	// user does not exist
		// 	throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		// }

		// if (true) {
		// 	// user does not have permission to kick
		// 	throw new HttpException(&quot;User is not in the room&quot;, HttpStatus.FORBIDDEN);
		// }

		// if (true) {
		// 	// user is trying to undo their own kick
		// 	throw new HttpException(&quot;User is the initiator&quot;, HttpStatus.BAD_REQUEST);
		// }
	}

	async getBannedUsers(
		roomID: string,
		userID: string | undefined,
	): Promise&lt;UserDto[]&gt; {
		// Implement the logic to get the banned users for the room
		console.log(roomID);
		const bannedUsers &#x3D; await this.prisma.banned.findMany({
			where: {
				room_id: roomID,
			},
		});
		const bannedUserIDs: string[] &#x3D; bannedUsers.map((banned) &#x3D;&gt; banned.user_id);
		const bannedUserDtos: UserDto[] &#x3D; await this.dtogen.generateMultipleUserDto(
			bannedUserIDs,
			userID,
		);
		return bannedUserDtos;
	}

	async banUser(
		roomID: string,
		initiatorID: string,
		bannedUserID: string,
	): Promise&lt;void&gt; {
		// Implement the logic to ban a user from the room
		console.log(roomID);
		console.log(initiatorID);
		console.log(bannedUserID);
		try {
			await this.leaveRoom(roomID, bannedUserID);
			await this.prisma.banned.create({
				data: {
					room_id: roomID,
					user_id: bannedUserID,
				},
			});
		} catch (error) {
			throw error;
		}
		throw new HttpException(&quot;User banned&quot;, HttpStatus.OK);
	}

	async undoBan(
		roomID: string,
		initiatorID: string,
		bannedUserID: string,
	): Promise&lt;void&gt; {
		// Implement the logic to undo the ban of a participant in the room
		console.log(roomID);
		console.log(initiatorID);
		console.log(bannedUserID);
		try {
			await this.prisma.banned.deleteMany({
				where: {
					room_id: roomID,
					user_id: bannedUserID,
				},
			});
		} catch (error) {
			throw error;
		}
		throw new HttpException(&quot;User unbanned&quot;, HttpStatus.OK);
	}

	async getCalendarFile(roomID: string): Promise&lt;File&gt; {
		// Implement the logic to get the calendar file for the room
		// if (true) {
		// 	// room does not exist
		// 	throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		// }
		// if (true) {
		// 	// room does not have any events
		// 	throw new HttpException(
		// 		&quot;Room does not have any events&quot;,
		// 		HttpStatus.NOT_FOUND,
		// 	);
		// }
		console.log(roomID);
		const bytes: BlobPart[] &#x3D; [];
		return new File(bytes, &quot;calendar.ics&quot;);
	}

	async splitRoom(roomID: string): Promise&lt;RoomDto&gt; {
		try {
			// Fetch audio features of the songs in the room queue
			// check if the room already has child rooms
			const childRooms: PrismaTypes.child_room[] | null &#x3D;
				await this.prisma.child_room.findMany({
					where: {
						parent_room_id: roomID,
					},
				});
			console.log(&quot;Child rooms&quot;, childRooms);
			if (!childRooms || childRooms.length !&#x3D;&#x3D; 0) {
				throw new HttpException(
					&quot;Room already has child rooms&quot;,
					HttpStatus.BAD_REQUEST,
				);
			}
			const audioFeatures: (Spotify.AudioFeatures &amp; {
				genre: string;
				songID: string;
			})[] &#x3D; await this.getAudioFeatures(roomID);
			if (!audioFeatures || audioFeatures.length &#x3D;&#x3D;&#x3D; 0) {
				throw new HttpException(
					&quot;Room does not have any events&quot;,
					HttpStatus.NOT_FOUND,
				);
			}
			console.log(&quot;Audio features&quot;);

			const features: number[][] &#x3D; audioFeatures.map((song) &#x3D;&gt; [
				song.danceability,
				song.energy,
				song.key,
				song.loudness,
				song.mode,
				song.speechiness,
				song.acousticness,
				song.instrumentalness,
				song.liveness,
				song.valence,
				song.tempo,
			]);

			// Apply K-means clustering with convergence check
			const maxIterations &#x3D; 100;
			const distinctivenessThreshold &#x3D; 0.5; // Define your threshold
			let clusters: KMeansResult &#x3D; kmeans(features, 2, { maxIterations: 20 });
			let canSplit &#x3D; false;
			for (let i &#x3D; 0; i &lt; maxIterations; i++) {
				clusters &#x3D; kmeans(features, 2, { maxIterations: 20 });
				if (this.checkConvergence(clusters, distinctivenessThreshold)) {
					canSplit &#x3D; true;
				}
			}
			console.log(&quot;Clusters&quot;, clusters);
			if (!canSplit) {
				throw new HttpException(&quot;Room cannot be split&quot;, HttpStatus.BAD_REQUEST);
			}

			console.log(&quot;Splitting room&quot;);

			// Assign songs to sub-rooms based on clusters
			const subRooms &#x3D; [0, 1].map((cluster: number) &#x3D;&gt; {
				return audioFeatures.filter(
					(_, index) &#x3D;&gt; clusters.clusters[index] &#x3D;&#x3D;&#x3D; cluster,
				);
			});
			console.log(&quot;Sub-rooms&quot;, subRooms);
			const childGenres &#x3D; subRooms.map((subRoom) &#x3D;&gt;
				this.genresFromCluster(subRoom.map((song) &#x3D;&gt; song.genre)),
			);

			console.log(childGenres);
			if (childGenres.length &lt; 2) {
				throw new HttpException(&quot;No genres found&quot;, HttpStatus.BAD_REQUEST);
			}

			// Create new rooms for the sub-rooms
			const parentRoom: PrismaTypes.room | null &#x3D;
				await this.prisma.room.findFirst({
					where: {
						room_id: roomID,
					},
				});
			if (!parentRoom) {
				throw new HttpException(&quot;Parent room not found&quot;, HttpStatus.NOT_FOUND);
			}
			try {
				const childRoom0: PrismaTypes.room | null &#x3D;
					await this.prisma.room.create({
						data: {
							name: parentRoom.name + &quot; - &quot; + childGenres[0],
							description: parentRoom.description,
							room_creator: parentRoom.room_creator,
							playlist_photo: parentRoom.playlist_photo,
							explicit: parentRoom.explicit,
							nsfw: parentRoom.nsfw,
							room_language: parentRoom.room_language,
							tags: [childGenres[0] ?? &quot;vibe&quot;],
						},
					});
				const childRoom1: PrismaTypes.room | null &#x3D;
					await this.prisma.room.create({
						data: {
							name: parentRoom.name + &quot; - &quot; + childGenres[1],
							description: parentRoom.description,
							room_creator: parentRoom.room_creator,
							playlist_photo: parentRoom.playlist_photo,
							explicit: parentRoom.explicit,
							nsfw: parentRoom.nsfw,
							room_language: parentRoom.room_language,
							tags: [childGenres[1] ?? &quot;vibe&quot;],
						},
					});

				if (!childRoom0 || !childRoom1) {
					throw new HttpException(
						&quot;Failed to create child rooms&quot;,
						HttpStatus.INTERNAL_SERVER_ERROR,
					);
				}

				await this.prisma.child_room.create({
					data: {
						parent_room_id: parentRoom.room_id,
						room_id: childRoom0.room_id,
					},
				});

				await this.prisma.child_room.create({
					data: {
						parent_room_id: parentRoom.room_id,
						room_id: childRoom1.room_id,
					},
				});

				// Move songs to sub-rooms
				const childRoom0Songs:
					| { room_id: string; song_id: string }[]
					| undefined &#x3D; subRooms[0]?.map((song) &#x3D;&gt; {
					return {
						room_id: childRoom0.room_id,
						song_id: song.songID,
					};
				});
				const childRoom1Songs:
					| { room_id: string; song_id: string }[]
					| undefined &#x3D; subRooms[1]?.map((song) &#x3D;&gt; {
					return {
						room_id: childRoom1.room_id,
						song_id: song.songID,
					};
				});
				if (childRoom0Songs) {
					console.log(&quot;Child room 0 songs&quot;, childRoom0Songs);
					await this.prisma.queue.createMany({
						data: childRoom0Songs,
					});
				}
				if (childRoom1Songs) {
					await this.prisma.queue.createMany({
						data: childRoom1Songs,
					});
				}
				const [parentRoomDto]: RoomDto[] &#x3D;
					await this.dtogen.generateMultipleRoomDto([roomID]);
				parentRoomDto.childrenRoomIDs &#x3D; [
					childRoom0.room_id,
					childRoom1.room_id,
				];
				return parentRoomDto;
			} catch (error) {
				throw new HttpException(
					&quot;Failed to create child rooms&quot;,
					HttpStatus.INTERNAL_SERVER_ERROR,
				);
			}
		} catch (error) {
			console.error(&quot;Error splitting room:&quot;, error);
			throw error;
		}
	}
	async canSplitRoom(roomID: string): Promise&lt;string[]&gt; {
		try {
			// Fetch audio features of the songs in the room queue
			const childrenRoom: PrismaTypes.child_room[] | null &#x3D;
				await this.prisma.child_room.findMany({
					where: {
						parent_room_id: roomID,
					},
				});
			if (!childrenRoom || childrenRoom.length !&#x3D;&#x3D; 0) {
				throw new HttpException(
					&quot;Room already has child rooms&quot;,
					HttpStatus.BAD_REQUEST,
				);
			}
			const audioFeatures: (Spotify.AudioFeatures &amp; { genre: string })[] &#x3D;
				await this.getAudioFeatures(roomID);
			if (!audioFeatures || audioFeatures.length &#x3D;&#x3D;&#x3D; 0) {
				throw new HttpException(
					&quot;Room does not have any events&quot;,
					HttpStatus.NOT_FOUND,
				);
			}

			const features: number[][] &#x3D; audioFeatures.map((song) &#x3D;&gt; [
				song.danceability,
				song.energy,
				song.key,
				song.loudness,
				song.mode,
				song.speechiness,
				song.acousticness,
				song.instrumentalness,
				song.liveness,
				song.valence,
				song.tempo,
			]);

			// Apply K-means clustering with convergence check
			const maxIterations &#x3D; 100;
			const distinctivenessThreshold &#x3D; 0.5; // Define your threshold
			let clusters: KMeansResult &#x3D; kmeans(features, 2, { maxIterations: 20 });
			let canSplit &#x3D; false;
			for (let i &#x3D; 0; i &lt; maxIterations; i++) {
				clusters &#x3D; kmeans(features, 2, { maxIterations: 20 });
				if (this.checkConvergence(clusters, distinctivenessThreshold)) {
					canSplit &#x3D; true;
				}
			}
			if (!canSplit) {
				throw new HttpException(&quot;Room cannot be split&quot;, HttpStatus.BAD_REQUEST);
			}

			// Assign songs to sub-rooms based on clusters
			console.log(&quot;Number of subrooms:&quot;, clusters.clusters);
			const subRooms &#x3D; [0, 1].map((cluster: number) &#x3D;&gt; {
				return audioFeatures.filter(
					(_, index) &#x3D;&gt; clusters.clusters[index] &#x3D;&#x3D;&#x3D; cluster,
				);
			});

			const childGenres &#x3D; subRooms.map((subRoom) &#x3D;&gt;
				this.genresFromCluster(subRoom.map((song) &#x3D;&gt; song.genre)),
			);

			console.log(childGenres);
			const distinctGenres &#x3D; [...new Set(childGenres)];
			if (distinctGenres.length &lt; 2) {
				throw new HttpException(&quot;No genres found&quot;, HttpStatus.BAD_REQUEST);
			}
			return distinctGenres;
		} catch (error) {
			console.error(&quot;Error splitting room:&quot;, error);
			throw error;
		}
	}

	checkConvergence(clusters: KMeansResult, threshold: number): boolean {
		const centroids &#x3D; clusters.centroids;
		let minDistance &#x3D; Infinity;

		for (let i &#x3D; 0; i &lt; centroids.length; i++) {
			for (let j &#x3D; i + 1; j &lt; centroids.length; j++) {
				const distance &#x3D; this.euclideanDistance(
					centroids[i] ?? [],
					centroids[j] ?? [],
				);
				if (distance &lt; minDistance) {
					minDistance &#x3D; distance;
				}
			}
		}

		return minDistance &gt; threshold;
	}

	euclideanDistance(point1: number[], point2: number[]): number {
		let sum &#x3D; 0;
		console.log(point1);
		for (let i &#x3D; 0; i &lt; point1.length; i++) {
			const val1: number &#x3D; point1[i] ?? 0;
			const val2: number &#x3D; point2[i] ?? 0;
			if (val1 &#x3D;&#x3D;&#x3D; undefined || val2 &#x3D;&#x3D;&#x3D; undefined) {
				break;
			}
			sum +&#x3D; Math.pow(val1 - val2, 2);
		}
		return Math.sqrt(sum);
	}

	async getAudioFeatures(
		roomID: string,
	): Promise&lt;(Spotify.AudioFeatures &amp; { genre: string; songID: string })[]&gt; {
		// Implement the logic to get the audio features for a song
		const songs: (PrismaTypes.queue &amp; { song: PrismaTypes.song })[] &#x3D;
			await this.prisma.queue.findMany({
				where: {
					room_id: roomID,
				},
				include: {
					song: true,
				},
			});
		console.log(&quot;Songs&quot;, songs);
		return songs.map((song) &#x3D;&gt; {
			return {
				...(JSON.parse(
					song.song.audio_features as unknown as string,
				) as unknown as Spotify.AudioFeatures),
				genre: song.song.genre ?? &quot;Unknown&quot;,
				songID: song.song.song_id,
			};
		});
	}
	genresFromCluster(cluster: string[]): string {
		const genreCounts: { [genre: string]: number } &#x3D; {};
		cluster.forEach((genre) &#x3D;&gt; {
			if (genre in genreCounts &amp;&amp; genreCounts[genre]) {
				genreCounts[genre]++;
			} else {
				genreCounts[genre] &#x3D; 1;
			}
		});

		const sortedGenres &#x3D; Object.keys(genreCounts).sort(
			(genre1, genre2) &#x3D;&gt;
				(genreCounts[genre2] ?? 0) - (genreCounts[genre1] ?? 0),
		);

		return sortedGenres[0] ?? &quot;Unknown&quot;;
	}

	async saveRoomPlaylist(roomID: string, userID: string): Promise&lt;void&gt; {
		if (!(await this.dbUtils.userExists(userID))) {
			throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		}
		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}
		const room: RoomDto &#x3D; await this.getRoomInfo(roomID);
		await this.spotifyService.saveRoomPlaylist(room, userID);
	}

	async unsaveRoomPlaylist(roomID: string, userID: string): Promise&lt;void&gt; {
		if (!(await this.dbUtils.userExists(userID))) {
			throw new HttpException(&quot;User does not exist&quot;, HttpStatus.NOT_FOUND);
		}
		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}
		const room: RoomDto &#x3D; await this.getRoomInfo(roomID);
		await this.spotifyService.unsaveRoomPlaylist(room, userID);
	}

	// async shareRoom(@Request() req: Request, @Param(&quot;roomID&quot;) roomID: string, @Body() users: string[]) {
	// 	const userInfo: JWTPayload &#x3D; this.auth.getUserInfo(req);
	// 	return await this.roomsService.shareRoom(roomID, userInfo.id, users);
	// }
	/*
	async sendMessage(message: DirectMessageDto): Promise&lt;DirectMessageDto&gt; {
		//send message to user
		try {
			const newMessage &#x3D; await this.prisma.message.create({
				data: {
					contents: message.messageBody,
					date_sent: message.dateSent,
					sender: message.sender.userID,
				},
			});
			const m: PrismaTypes.private_message &#x3D;
				await this.prisma.private_message.create({
					data: {
						users: {
							connect: {
								user_id: message.recipient.userID,
							},
						},
						message: {
							connect: {
								message_id: newMessage.message_id,
							},
						},
					},
				});
			console.log(&quot;new DM: &quot;);
			console.log(m);
			return await this.dtogen.generateDirectMessageDto(m.p_message_id);
		} catch (e) {
			throw new Error(&quot;Failed to send message&quot;);
		}
	}
	*/
	async shareRoom(
		roomID: string,
		userID: string,
		users: string[],
	): Promise&lt;void&gt; {
		if (users.length &#x3D;&#x3D;&#x3D; 0) {
			throw new HttpException(&quot;User list is empty&quot;, HttpStatus.BAD_REQUEST);
		}
		await this.dbUtils.usersExist([userID, ...users]).then((users) &#x3D;&gt; {
			users.forEach((user) &#x3D;&gt; {
				if (!user.exists) {
					throw new HttpException(
						&#x60;User (with id &#x27;${user.userID}&#x27;) does not exist&#x60;,
						HttpStatus.NOT_FOUND,
					);
				}
			});
		});
		if (!(await this.dbUtils.roomExists(roomID))) {
			throw new HttpException(&quot;Room does not exist&quot;, HttpStatus.NOT_FOUND);
		}
		const room: RoomDto &#x3D; await this.getRoomInfo(roomID);
		const roomShares: ({
			private_message: {
				p_message_id: string;
				recipient: string;
			} | null;
		} &amp; {
			message_id: string;
			contents: string;
			date_sent: Date;
			sender: string;
		})[] &#x3D; await this.prisma.$transaction(
			users.map((user) &#x3D;&gt; {
				return this.prisma.message.create({
					data: {
						contents: &#x60;##${room.roomID}##&#x60;,
						date_sent: new Date(),
						users: {
							connect: {
								user_id: userID, // sender
							},
						},
						private_message: {
							create: {
								users: {
									connect: {
										user_id: user, // recipient
									},
								},
							},
						},
					},
					include: {
						private_message: true,
					},
				});
			}),
		);
		if (this.server) {
			const roomShareMessages: ({
				message: {
					message_id: string;
					contents: string;
					date_sent: Date;
					sender: string;
				};
			} &amp; {
				p_message_id: string;
				recipient: string;
			})[] &#x3D; [];
			for (const rs of roomShares) {
				if (rs.private_message !&#x3D;&#x3D; null) {
					roomShareMessages.push({
						message: {
							message_id: rs.message_id,
							contents: rs.contents,
							date_sent: rs.date_sent,
							sender: rs.sender,
						},
						p_message_id: rs.private_message.p_message_id,
						recipient: rs.private_message.recipient,
					});
				}
			}
			const roomShareDMs: DirectMessageDto[] &#x3D;
				await this.dtogen.generateMultipleDirectMessageDto(roomShareMessages);
			this.dmUsersService.shareRoom(this.server, roomShareDMs);
		}
		throw new HttpException(&#x60;Room shared&#x60;, HttpStatus.CREATED);
	}
}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'UserActionDto.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
