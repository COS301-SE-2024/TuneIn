// tasks.processor.ts
import { Processor, Process } from "@nestjs/bull";
import { Job } from "bull";
import { SpotifyTokenPair } from "../auth/spotify/spotifyauth.service";
import { SpotifyService } from "../spotify/spotify.service";
import { Prisma } from "@prisma/client";
import * as PrismaTypes from "@prisma/client";
import * as Spotify from "@spotify/web-api-ts-sdk";
import { PrismaService } from "../../prisma/prisma.service";
// import { MurLockService } from "murlock";

@Processor("task-queue")
export class TasksProcessor {
	constructor(
		private readonly spotifyService: SpotifyService,
		private readonly prisma: PrismaService, // private readonly murLockService: MurLockService,
	) {}

	@Process("process-task")
	async handleTask(job: Job) {
		console.log("Processing task:", job.data);
		// Your background task processing logic here
	}

	@Process("import-library")
	async importUserLibrary(job: Job) {
		console.log(`${job.name} job started`);
		const tk: SpotifyTokenPair = job.data.token;
		const userID: string = job.data.user_id;
		if (new Date().getTime() > tk.epoch_expiry) {
			throw new Error("Token has expired");
		}
		console.log(`Importing user library for user: ${userID}`);

		const userPlaylists: PrismaTypes.playlist[] =
			await this.prisma.playlist.findMany({
				where: {
					user_id: userID,
				},
			});

		// handle user's liked songs
		let start = new Date().valueOf();
		console.log(`Getting liked songs...`);
		const likedSongs: Spotify.SavedTrack[] =
			await this.spotifyService.getAllLikedSongs(userID);
		console.log(`Got liked songs in ${new Date().valueOf() - start}ms`);
		start = new Date().valueOf();
		const likedTracks: Spotify.Track[] = likedSongs.map((track) => track.track);
		const likedSongsDB: PrismaTypes.song[] =
			await this.spotifyService.addTracksToDB(likedTracks);
		console.log(`Added liked songs to DB in ${new Date().valueOf() - start}ms`);
		const likedSongIDs: string[] = likedSongsDB.map((song) => song.song_id);
		const likedSongsPlaylistInDB: PrismaTypes.playlist | undefined =
			userPlaylists.find(
				(userPlaylist) =>
					userPlaylist.name === "Liked Songs (generated by TuneIn)",
			);
		if (likedSongsPlaylistInDB) {
			await this.prisma.playlist.update({
				where: {
					playlist_id: likedSongsPlaylistInDB.playlist_id,
				},
				data: {
					playlist: likedSongIDs,
				},
			});
		} else {
			const likedSongsPlaylist: Prisma.playlistCreateInput = {
				name: "Liked Songs (generated by TuneIn)",
				users: {
					connect: { user_id: userID },
				},
				playlist: likedSongIDs,
			};
			await this.prisma.playlist.create({
				data: likedSongsPlaylist,
			});
		}
		console.log(`Finished importing liked songs`);

		// handle user's playlists
		console.log(`Getting user playlists...`);
		start = new Date().valueOf();
		const playlists: Spotify.SimplifiedPlaylist[] =
			await this.spotifyService.getUserPlaylists(userID);
		console.log(`Got user playlists in ${new Date().valueOf() - start}ms`);
		console.log(`Getting playlist tracks...`);
		start = new Date().valueOf();
		const playlistTracksPromises = playlists.map(async (playlist) => {
			return this.spotifyService.getUserPlaylistTracks(userID, playlist.id);
		});
		const playlistTracks: Spotify.Track[][] = await Promise.all(
			playlistTracksPromises,
		).then((tracks) => {
			const totalTracks: number = tracks.reduce(
				(acc, val) => acc + val.length,
				0,
			);
			console.log(
				`Got all playlist tracks (${totalTracks}) for ${
					playlists.length
				} playlists in ${new Date().valueOf() - start}ms`,
			);
			return tracks;
		});
		console.log(`Adding playlist songs to DB...`);
		start = new Date().valueOf();
		await this.spotifyService.addTracksToDB(playlistTracks.flat());
		console.log(
			`Added all playlist songs to DB in ${new Date().valueOf() - start}ms`,
		);
		console.log(`Creating playlists in DB...`);
		start = new Date().valueOf();
		const playlistsCreationPromises: Prisma.PrismaPromise<PrismaTypes.playlist>[] =
			[];
		for (let i = 0; i < playlists.length; i++) {
			const playlist = playlists[i];
			const playlistTrackIDs: string[] = playlistTracks[i].map(
				(track) => track.id,
			);
			const userPlaylistInDB: PrismaTypes.playlist | undefined =
				userPlaylists.find(
					(userPlaylist) => userPlaylist.name === playlist.name,
				);
			if (userPlaylistInDB) {
				playlistsCreationPromises.push(
					this.prisma.playlist.update({
						where: {
							playlist_id: userPlaylistInDB.playlist_id,
							description: playlist.description,
						},
						data: {
							playlist: playlistTrackIDs,
						},
					}),
				);
			} else {
				const newPlaylist: Prisma.playlistCreateInput = {
					name: playlist.name,
					users: {
						connect: { user_id: userID },
					},
					playlist: playlistTrackIDs,
					description: playlist.description,
				};
				playlistsCreationPromises.push(
					this.prisma.playlist.create({
						data: newPlaylist,
					}),
				);
			}
		}
		await Promise.all(playlistsCreationPromises);
		console.log(
			`Finished creating playlists in DB in ${new Date().valueOf() - start}ms`,
		);
	}

	// @Process("get-room-spotify-info")
	// async getRoomSpotifyInfo(job: Job) {
	// 	console.log(`${job.name} job started`);
	// 	const {
	// 		room,
	// 	}: {
	// 		room: ActiveRoom;
	// 	} = job.data;
	// 	const api: Spotify.SpotifyApi = this.spotifyService.getUserlessAPI();
	// 	console.log(
	// 		`Getting Spotify info for room '${room.room.room_name}' (${room.room.roomID})`,
	// 	);
	// 	const start = new Date().valueOf();
	// 	await room.getSpotifyInfo(api, this.prisma, this.murLockService);
	// 	await room.flushtoDB(
	// 		this.spotifyService,
	// 		this.prisma,
	// 		this.murLockService,
	// 	);
	// 	const end = new Date().valueOf();
	// 	const milliseconds = end - start;
	// 	console.log(
	// 		`Finished getting Spotify info for room '${room.room.room_name}' (${room.room.roomID}) in ${milliseconds}ms`,
	// 	);
	// }

	@Process("fix-spotify-info")
	async fixSpotifyInfo(job: Job) {
		console.log(`${job.name} job started`);
		await this.spotifyService.fixSpotifyInfo();
	}
}
