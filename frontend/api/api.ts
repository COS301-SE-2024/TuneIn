/* tslint:disable */
/* eslint-disable */
/**
 * TuneIn API
 * The API for the TuneIn application, handling all the backend logic and making it available to the frontend.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CombinedSearchHistory
 */
export interface CombinedSearchHistory {
    /**
     * Mixed list of rooms, users, or strings
     * @type {Array<string>}
     * @memberof CombinedSearchHistory
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface CombinedSearchResults
 */
export interface CombinedSearchResults {
    /**
     * List of rooms
     * @type {Array<RoomDto>}
     * @memberof CombinedSearchResults
     */
    'rooms': Array<RoomDto>;
    /**
     * List of users
     * @type {Array<UserDto>}
     * @memberof CombinedSearchResults
     */
    'users': Array<UserDto>;
}
/**
 * 
 * @export
 * @interface CreateRoomDto
 */
export interface CreateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_temporary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_scheduled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_explicit_content'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_nsfw_content'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_image'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRoomDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface LiveChatMessageDto
 */
export interface LiveChatMessageDto {
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'messageBody': string;
    /**
     * 
     * @type {UserDto}
     * @memberof LiveChatMessageDto
     */
    'sender': UserDto;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'roomID': string;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'dateCreated'?: string;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * The Cognito JWT token
     * @type {string}
     * @memberof LoginBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RefreshBody
 */
export interface RefreshBody {
    /**
     * The JWT token to be refreshed
     * @type {string}
     * @memberof RefreshBody
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterBody
 */
export interface RegisterBody {
    /**
     * The user\'s username
     * @type {string}
     * @memberof RegisterBody
     */
    'username': string;
    /**
     * The user\'s Cognito sub/ID
     * @type {string}
     * @memberof RegisterBody
     */
    'userCognitoSub': string;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RoomDto
 */
export interface RoomDto {
    /**
     * 
     * @type {UserDto}
     * @memberof RoomDto
     */
    'creator': UserDto;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'roomID': string;
    /**
     * 
     * @type {number}
     * @memberof RoomDto
     */
    'participant_count': number;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_temporary': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_scheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_explicit_content': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_nsfw_content': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_image': string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof RoomDto
     */
    'current_song': SongInfoDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoomDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchHistoryDto
 */
export interface SearchHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_term': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_time': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SongInfoDto
 */
export interface SongInfoDto {
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfoDto
     */
    'artists': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'cover': string;
    /**
     * 
     * @type {object}
     * @memberof SongInfoDto
     */
    'start_time': object;
}
/**
 * 
 * @export
 * @interface SpotifyTokenResponse
 */
export interface SpotifyTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof SpotifyTokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UpdateRoomDto
 */
export interface UpdateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_temporary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_scheduled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_explicit_content'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_nsfw_content'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_image'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRoomDto
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_picture_url'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'followers'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'following'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'links'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'bio'?: string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof UpdateUserDto
     */
    'current_song'?: SongInfoDto;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_genres'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_songs'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_rooms'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'recent_rooms'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'friendship'?: object;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_picture_url': string;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'followers': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'following': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'links': object;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio': string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof UserDto
     */
    'current_song': SongInfoDto;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_genres': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_songs': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_rooms': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'recent_rooms': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'friendship'?: object;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpotifyTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginBody: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginBody' is not null or undefined
            assertParamExists('login', 'loginBody', loginBody)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshBody: RefreshBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshBody' is not null or undefined
            assertParamExists('refresh', 'refreshBody', refreshBody)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSpotifyTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerBody: RegisterBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerBody' is not null or undefined
            assertParamExists('register', 'registerBody', registerBody)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyCallback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('spotifyCallback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('spotifyCallback', 'state', state)
            const localVarPath = `/auth/spotify/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the Expo app with the Spotify auth code
         * @summary Spotify OAuth Redirect
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyRedirect: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('spotifyRedirect', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('spotifyRedirect', 'state', state)
            const localVarPath = `/auth/spotify/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpotifyTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpotifyTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getSpotifyTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginBody: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshSpotifyTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshSpotifyTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshSpotifyTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerBody: RegisterBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyCallback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the Expo app with the Spotify auth code
         * @summary Spotify OAuth Redirect
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyRedirect(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyRedirect(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpotifyTokens(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenResponse> {
            return localVarFp.getSpotifyTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginBody: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.login(loginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.refresh(refreshBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSpotifyTokens(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenResponse> {
            return localVarFp.refreshSpotifyTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerBody: RegisterBody, options?: RawAxiosRequestConfig): AxiosPromise<RegisterBody> {
            return localVarFp.register(registerBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.spotifyCallback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the Expo app with the Spotify auth code
         * @summary Spotify OAuth Redirect
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyRedirect(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.spotifyRedirect(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Returns the user\'s Spotify Auth Tokens
     * @summary Get Spotify Auth Tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getSpotifyTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getSpotifyTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
     * @summary Authenticate a user using a Cognito JWT token
     * @param {LoginBody} loginBody Cognito JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginBody: LoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
     * @summary Refresh an expired (or almost expired) JWT token
     * @param {RefreshBody} refreshBody The expired JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refresh(refreshBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
     * @summary Manually Refresh Spotify Auth Tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshSpotifyTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshSpotifyTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
     * @summary Register a new user in the API using Cognito
     * @param {RegisterBody} registerBody User\&#39;s Cognito information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerBody: RegisterBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
     * @summary Callback for Spotify Auth
     * @param {string} code The authorization code returned by Spotify after user consent
     * @param {string} state A unique state value to prevent CSRF attacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyCallback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the Expo app with the Spotify auth code
     * @summary Spotify OAuth Redirect
     * @param {string} code The authorization code returned by Spotify after user consent
     * @param {string} state A unique state value to prevent CSRF attacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyRedirect(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyRedirect(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Hello World!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileUploadApi - axios parameter creator
 * @export
 */
export const FileUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileUploadApi - functional programming interface
 * @export
 */
export const FileUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileUploadApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileUploadApi - factory interface
 * @export
 */
export const FileUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileUploadApiFp(configuration)
    return {
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileUploadApi - object-oriented interface
 * @export
 * @class FileUploadApi
 * @extends {BaseAPI}
 */
export class FileUploadApi extends BaseAPI {
    /**
     * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
     * @summary Upload a file to our AWS S3 storage bucket
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileUploadApi
     */
    public uploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return FileUploadApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async genresControllerGetAllGenres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.genresControllerGetAllGenres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.genresControllerGetAllGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenresApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.genresControllerGetAllGenres(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @summary Get all genres
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public genresControllerGetAllGenres(options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).genresControllerGetAllGenres(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomAnalyticsApi - axios parameter creator
 * @export
 */
export const RoomAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the analytics of the room as a RoomAnalyticsDto.
         * @summary Get room analytics
         * @param {string} roomID The ID of the room to get analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contributor analytics of the room as a RoomAnalyticsContributorsDto.
         * @summary Get room contributor analytics
         * @param {string} roomID The ID of the room to get contributor analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomContributorsAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomContributorsAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/contributors`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInteractionAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomInteractionAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/interactions`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomParticipationAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomParticipationAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/participation`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the queue analytics of the room as a RoomAnalyticsQueueDto.
         * @summary Get room queue analytics
         * @param {string} roomID The ID of the room to get queue analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueueAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomQueueAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/queue`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the song analytics of the room as a RoomAnalyticsSongsDto.
         * @summary Get room song analytics
         * @param {string} roomID The ID of the room to get song analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomSongsAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomSongsAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the voting analytics of the room as a RoomAnalyticsVotesDto.
         * @summary Get room voting analytics
         * @param {string} roomID The ID of the room to get voting analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomVotesAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomVotesAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/votes`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomAnalyticsApi - functional programming interface
 * @export
 */
export const RoomAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getKeyMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the analytics of the room as a RoomAnalyticsDto.
         * @summary Get room analytics
         * @param {string} roomID The ID of the room to get analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the contributor analytics of the room as a RoomAnalyticsContributorsDto.
         * @summary Get room contributor analytics
         * @param {string} roomID The ID of the room to get contributor analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomContributorsAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomContributorsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomInteractionAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomInteractionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomParticipationAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomParticipationAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the queue analytics of the room as a RoomAnalyticsQueueDto.
         * @summary Get room queue analytics
         * @param {string} roomID The ID of the room to get queue analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomQueueAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomQueueAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the song analytics of the room as a RoomAnalyticsSongsDto.
         * @summary Get room song analytics
         * @param {string} roomID The ID of the room to get song analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomSongsAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomSongsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the voting analytics of the room as a RoomAnalyticsVotesDto.
         * @summary Get room voting analytics
         * @param {string} roomID The ID of the room to get voting analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomVotesAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomVotesAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomAnalyticsApi - factory interface
 * @export
 */
export const RoomAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomAnalyticsApiFp(configuration)
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getKeyMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the analytics of the room as a RoomAnalyticsDto.
         * @summary Get room analytics
         * @param {string} roomID The ID of the room to get analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contributor analytics of the room as a RoomAnalyticsContributorsDto.
         * @summary Get room contributor analytics
         * @param {string} roomID The ID of the room to get contributor analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomContributorsAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomInteractionAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomParticipationAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the queue analytics of the room as a RoomAnalyticsQueueDto.
         * @summary Get room queue analytics
         * @param {string} roomID The ID of the room to get queue analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomQueueAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the song analytics of the room as a RoomAnalyticsSongsDto.
         * @summary Get room song analytics
         * @param {string} roomID The ID of the room to get song analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomSongsAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the voting analytics of the room as a RoomAnalyticsVotesDto.
         * @summary Get room voting analytics
         * @param {string} roomID The ID of the room to get voting analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomVotesAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomAnalyticsApi - object-oriented interface
 * @export
 * @class RoomAnalyticsApi
 * @extends {BaseAPI}
 */
export class RoomAnalyticsApi extends BaseAPI {
    /**
     * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
     * @summary Get key metrics for user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getKeyMetrics(options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getKeyMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the analytics of the room as a RoomAnalyticsDto.
     * @summary Get room analytics
     * @param {string} roomID The ID of the room to get analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the contributor analytics of the room as a RoomAnalyticsContributorsDto.
     * @summary Get room contributor analytics
     * @param {string} roomID The ID of the room to get contributor analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomContributorsAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
     * @summary Get room interaction analytics
     * @param {string} roomID The ID of the room to get interaction analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomInteractionAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
     * @summary Get room participation analytics
     * @param {string} roomID The ID of the room to get participation analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomParticipationAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the queue analytics of the room as a RoomAnalyticsQueueDto.
     * @summary Get room queue analytics
     * @param {string} roomID The ID of the room to get queue analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomQueueAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the song analytics of the room as a RoomAnalyticsSongsDto.
     * @summary Get room song analytics
     * @param {string} roomID The ID of the room to get song analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomSongsAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the voting analytics of the room as a RoomAnalyticsVotesDto.
     * @summary Get room voting analytics
     * @param {string} roomID The ID of the room to get voting analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomVotesAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID The ID of the room to add the song to.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongToQueue: async (roomID: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('addSongToQueue', 'roomID', roomID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addSongToQueue', 'body', body)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('bookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/bookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clears the queue of the room except for the current song.
         * @summary Clear the queue of a room
         * @param {string} roomID The ID of the room to clear the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomQueue: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('clearRoomQueue', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('deleteRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSong: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getCurrentSong', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs/current`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveChatHistory: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getLiveChatHistory', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/chat/history`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRooms: async (none: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'none' is not null or undefined
            assertParamExists('getNewRooms', 'none', none)
            const localVarPath = `/rooms/new`
                .replace(`{${"none"}}`, encodeURIComponent(String(none)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomInfo', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the queue of the room as an array of SongInfoDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueue: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomQueue', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomUsers: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomUsers', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/users`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('joinRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/join`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('leaveRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/leave`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoomInfo: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('putRoomInfo', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('putRoomInfo', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID The ID of the room to archive songs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerArchiveRoomSongs: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerArchiveRoomSongs', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/archive/playlist`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteArchivedSongs: async (playlistID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('roomsControllerDeleteArchivedSongs', 'playlistID', playlistID)
            const localVarPath = `/rooms/archive/playlist/{playlistID}`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetArchivedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/archive/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('unbookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/unbookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomInfo: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('updateRoomInfo', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('updateRoomInfo', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID The ID of the room to add the song to.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSongToQueue(roomID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.addSongToQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.bookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clears the queue of the room except for the current song.
         * @summary Clear the queue of a room
         * @param {string} roomID The ID of the room to clear the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearRoomQueue(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearRoomQueue(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.clearRoomQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentSong(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentSong(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getCurrentSong']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveChatMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveChatHistory(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getLiveChatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewRooms(none: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewRooms(none, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getNewRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomInfo(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomInfo(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the queue of the room as an array of SongInfoDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomQueue(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomQueue(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomUsers(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomUsers(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.joinRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.leaveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putRoomInfo(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.putRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID The ID of the room to archive songs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerArchiveRoomSongs(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerArchiveRoomSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerDeleteArchivedSongs(playlistID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerDeleteArchivedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetArchivedSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetArchivedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.unbookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoomInfo(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.updateRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID The ID of the room to add the song to.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addSongToQueue(roomID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Clears the queue of the room except for the current song.
         * @summary Clear the queue of a room
         * @param {string} roomID The ID of the room to clear the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomQueue(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearRoomQueue(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.deleteRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSong(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCurrentSong(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveChatMessageDto>> {
            return localVarFp.getLiveChatHistory(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRooms(none: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getNewRooms(none, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.getRoomInfo(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the queue of the room as an array of SongInfoDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueue(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRoomQueue(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomUsers(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getRoomUsers(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.joinRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.leaveRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putRoomInfo(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID The ID of the room to archive songs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerArchiveRoomSongs(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerDeleteArchivedSongs(playlistID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetArchivedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unbookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.updateRoomInfo(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 
     * @summary Add a song to the queue of a room
     * @param {string} roomID The ID of the room to add the song to.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public addSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).addSongToQueue(roomID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the room to the user\'s bookmarks.
     * @summary Bookmark a room
     * @param {string} roomID The ID of the room to bookmark.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).bookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clears the queue of the room except for the current song.
     * @summary Clear the queue of a room
     * @param {string} roomID The ID of the room to clear the queue for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public clearRoomQueue(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).clearRoomQueue(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room
     * @param {string} roomID The ID of the room to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public deleteRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).deleteRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the song currently playing in the room.
     * @summary Get the current song of a room
     * @param {string} roomID The ID of the room to get the current song for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getCurrentSong(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getCurrentSong(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the chat history of the room as an array of LiveChatMessageDto.
     * @summary Get the chat history of a room
     * @param {string} roomID The ID of the room to get the chat history for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getLiveChatHistory(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the new public rooms as an array of RoomDto.
     * @summary Get newly created public rooms
     * @param {any} none 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getNewRooms(none: any, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getNewRooms(none, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the room info as a RoomDto.
     * @summary Get room info
     * @param {string} roomID The ID of the room to get info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomInfo(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomInfo(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the queue of the room as an array of SongInfoDto.
     * @summary Get the queue of a room
     * @param {string} roomID The ID of the room to get the queue for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomQueue(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomQueue(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the users in the room as an array of UserDto.
     * @summary Get users in a room
     * @param {string} roomID The ID of the room to get users for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomUsers(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomUsers(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the current user as a participant to the room.
     * @summary Join a room
     * @param {string} roomID The ID of the room to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public joinRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).joinRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the current user as a participant to the room.
     * @summary Leave a room
     * @param {string} roomID The ID of the room to leave.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public leaveRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).leaveRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room info
     * @param {string} roomID The ID of the room to update.
     * @param {UpdateRoomDto} updateRoomDto The updated room info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).putRoomInfo(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a room\'s songs
     * @param {string} roomID The ID of the room to archive songs for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerArchiveRoomSongs(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user\'s archived songs
     * @param {string} playlistID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerDeleteArchivedSongs(playlistID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s archived songs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetArchivedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the room from the user\'s bookmarks.
     * @summary Unbookmark a room
     * @param {string} roomID The ID of the room to unbookmark.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).unbookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room info
     * @param {string} roomID The ID of the room to update.
     * @param {UpdateRoomDto} updateRoomDto The updated room info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).updateRoomInfo(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchRooms: async (q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('advancedSearchRooms', 'q', q)
            const localVarPath = `/search/rooms/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (participantCount !== undefined) {
                localVarQueryParameter['participant_count'] = participantCount;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (isTemp !== undefined) {
                localVarQueryParameter['is_temp'] = isTemp;
            }

            if (isPriv !== undefined) {
                localVarQueryParameter['is_priv'] = isPriv;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['is_scheduled'] = isScheduled;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['explicit'] = explicit;
            }

            if (nsfw !== undefined) {
                localVarQueryParameter['nsfw'] = nsfw;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchUsers: async (q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('advancedSearchUsers', 'q', q)
            const localVarPath = `/search/users/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            if (followers !== undefined) {
                localVarQueryParameter['followers'] = followers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSearchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRooms: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchRooms', 'q', q)
            const localVarPath = `/search/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchUsers', 'q', q)
            const localVarPath = `/search/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.advancedSearchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.advancedSearchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearSearchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearSearchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearSearchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CombinedSearchHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRooms(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSearchHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearSearchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearUsersHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<CombinedSearchResults> {
            return localVarFp.search(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<CombinedSearchHistory>> {
            return localVarFp.searchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchRooms(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(q: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.searchUsers(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchUsersHistory(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Advanced search for rooms by various parameters.
     * @summary Advanced search for rooms
     * @param {string} q A room name
     * @param {string} [creatorUsername] A room creator\&#39;s username
     * @param {string} [creatorName] A room creator\&#39;s profile name
     * @param {number} [participantCount] Minimum number of participants
     * @param {string} [description] A string to find in the room description
     * @param {boolean} [isTemp] Is the room temporary?
     * @param {boolean} [isPriv] Is the room private?
     * @param {boolean} [isScheduled] Is the room scheduled?
     * @param {string} [startDate] Only if scheduled, the start date
     * @param {string} [endDate] Only if scheduled, the end date
     * @param {string} [lang] The room language (as a ISO 639-1 code)
     * @param {boolean} [explicit] Is the room explicit?
     * @param {boolean} [nsfw] Is the room NSFW?
     * @param {string} [tags] A comma separated list of tags to compare
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Advanced search for users by various parameters.
     * @summary Advanced search for users
     * @param {string} q A username or profile name
     * @param {string} [creatorUsername] A user\&#39;s username
     * @param {string} [creatorName] A user\&#39;s profile name
     * @param {number} [following] Minimum number of following
     * @param {number} [followers] Minimum number of followers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear room search history for the user.
     * @summary Clear room search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear search history for the user.
     * @summary Clear search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearSearchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearSearchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear user search history for the user.
     * @summary Clear user search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for rooms and users by room name, creator name or username.
     * @summary Search for rooms and users
     * @param {string} q A room name / username
     * @param {string} [creator] A room creator\&#39;s profile name or username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get search history (including objects discovered from search)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for rooms by room name or creator name / username.
     * @summary Search for rooms
     * @param {string} q A room name
     * @param {string} [creator] A room creator\&#39;s profile name / username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchRooms(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recently searched rooms by the user.
     * @summary Get recently searched rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for users by username or profile name.
     * @summary Search for users
     * @param {string} q A username or profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsers(q: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsers(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recently searched users by the user.
     * @summary Get recently searched users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('acceptFriendRequest', 'username', username)
            const localVarPath = `/users/{username}/accept`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        befriendUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('befriendUser', 'username', username)
            const localVarPath = `/users/{username}/befriend`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (createRoomDto: CreateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDto' is not null or undefined
            assertParamExists('createRoom', 'createRoomDto', createRoomDto)
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('followUser', 'username', username)
            const localVarPath = `/users/{username}/follow`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRoom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/dms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (none: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'none' is not null or undefined
            assertParamExists('getFollowers', 'none', none)
            const localVarPath = `/users/followers`
                .replace(`{${"none"}}`, encodeURIComponent(String(none)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getProfileByUsername', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('patchProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('putProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequest: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('rejectFriendRequest', 'username', username)
            const localVarPath = `/users/{username}/reject`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('unfollowUser', 'username', username)
            const localVarPath = `/users/{username}/unfollow`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriendUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('unfriendUser', 'username', username)
            const localVarPath = `/users/{username}/unfriend`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequest(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequest(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.acceptFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async befriendUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.befriendUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.befriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoom(createRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.followUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentRoom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentRoom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getDMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(none: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowers(none, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriendRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFriendRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFriendRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getRecentRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getRecommendedRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.patchProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.putProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFriendRequest(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFriendRequest(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.rejectFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unfollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfriendUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfriendUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unfriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.acceptFriendRequest(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        befriendUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.befriendUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.createRoom(createRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.followUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getBookmarks(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRoom(options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.getCurrentRoom(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMs(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getDMs(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(none: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFollowers(none, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFollowing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendRequests(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFriendRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getProfileByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRecentRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRecommendedRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getUserFriends(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getUserRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.patchProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.putProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequest(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.rejectFriendRequest(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.unfollowUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriendUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.unfriendUser(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Accept a friend request from the user with the given username.
     * @summary Accept a friend request from the given user
     * @param {string} username Our new friend. The username of the user to accept a friend request from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptFriendRequest(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptFriendRequest(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a friend request to the user with the given username.
     * @summary Send a friend request to the given user
     * @param {string} username The username of the user to send a friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public befriendUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).befriendUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new room with the given information.
     * @summary Create a new room
     * @param {CreateRoomDto} createRoomDto The room to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createRoom(createRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Follow the user with the given username.
     * @summary Follow the given user
     * @param {string} username The username of the user to follow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public followUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).followUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the rooms that the user has bookmarked.
     * @summary Get the authorized user\'s bookmarks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBookmarks(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getBookmarks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the room that the user is currently in.
     * @summary Get a user\'s current room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentRoom(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentRoom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the last DMs either sent to or received from another user
     * @summary Get the last DMs sent to or received from another user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDMs(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getDMs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the users that follow the authenticated user.
     * @summary Get a user\'s followers
     * @param {any} none 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFollowers(none: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowers(none, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the users that the authenticated user follows.
     * @summary Get a user\'s following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFollowing(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFriendRequests(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFriendRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile info of the currently authenticated user.
     * @summary Get current user\'s profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfile(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile info of the user with the given username.
     * @summary Get user profile info by username
     * @param {string} username The username of the user to fetch profile info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfileByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s most recently visited rooms.
     * @summary Get a user\'s recent rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getRecentRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRecentRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the rooms that are recommended for the user.
     * @summary Get a user\'s recommended rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getRecommendedRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRecommendedRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friends
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFriends(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserFriends(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the rooms that the user created.
     * @summary Get the user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the profile info of the currently authenticated user.
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto The updated user profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).patchProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the profile info of the currently authenticated user.
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto The updated user profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).putProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject a friend request from the user with the given username.
     * @summary Reject a friend request from the given user
     * @param {string} username The username of the user whose friend request we are rejecting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public rejectFriendRequest(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).rejectFriendRequest(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfollow the user with the given username.
     * @summary Unfollow the given user
     * @param {string} username The username of the user to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unfollowUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unfollowUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End friendship with the user with the given username.
     * @summary End friendship with the given user
     * @param {string} username The username of the user to end friendship with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unfriendUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unfriendUser(username, options).then((request) => request(this.axios, this.basePath));
    }
}



