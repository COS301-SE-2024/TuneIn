/* tslint:disable */
/* eslint-disable */
/**
 * TuneIn API
 * The API for the TuneIn application, handling all the backend logic and making it available to the frontend.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CombinedSearchHistory
 */
export interface CombinedSearchHistory {
    /**
     * Mixed list of rooms, users, or strings
     * @type {Array<string>}
     * @memberof CombinedSearchHistory
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface CombinedSearchResults
 */
export interface CombinedSearchResults {
    /**
     * List of rooms
     * @type {Array<RoomDto>}
     * @memberof CombinedSearchResults
     */
    'rooms': Array<RoomDto>;
    /**
     * List of users
     * @type {Array<UserDto>}
     * @memberof CombinedSearchResults
     */
    'users': Array<UserDto>;
}
/**
 * 
 * @export
 * @interface CreateRoomDto
 */
export interface CreateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_temporary': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_scheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_explicit_content': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_nsfw_content': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRoomDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface LiveChatMessageDto
 */
export interface LiveChatMessageDto {
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'messageBody': string;
    /**
     * 
     * @type {UserDto}
     * @memberof LiveChatMessageDto
     */
    'sender': UserDto;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'roomID': string;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'dateCreated': string;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * The Cognito JWT token
     * @type {string}
     * @memberof LoginBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RefreshBody
 */
export interface RefreshBody {
    /**
     * The JWT token to be refreshed
     * @type {string}
     * @memberof RefreshBody
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterBody
 */
export interface RegisterBody {
    /**
     * The user\'s username
     * @type {string}
     * @memberof RegisterBody
     */
    'username': string;
    /**
     * The user\'s Cognito sub/ID
     * @type {string}
     * @memberof RegisterBody
     */
    'userCognitoSub': string;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterBody
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RoomDto
 */
export interface RoomDto {
    /**
     * 
     * @type {UserDto}
     * @memberof RoomDto
     */
    'creator': UserDto;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'roomID': string;
    /**
     * 
     * @type {number}
     * @memberof RoomDto
     */
    'participant_count': number;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_temporary': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_scheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_explicit_content': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_nsfw_content': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_image': string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof RoomDto
     */
    'current_song': SongInfoDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoomDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchHistoryDto
 */
export interface SearchHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_term': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_time': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SongInfoDto
 */
export interface SongInfoDto {
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfoDto
     */
    'artists': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'cover': string;
    /**
     * 
     * @type {object}
     * @memberof SongInfoDto
     */
    'start_time': object;
}
/**
 * 
 * @export
 * @interface SpotifyTokenResponse
 */
export interface SpotifyTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof SpotifyTokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UpdateRoomDto
 */
export interface UpdateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_temporary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_scheduled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_explicit_content'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_nsfw_content'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_image'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRoomDto
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_picture_url'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'followers'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'following'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'links'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'bio'?: string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof UpdateUserDto
     */
    'current_song'?: SongInfoDto;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_genres'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_songs'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'fav_rooms'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'recent_rooms'?: object;
    /**
     * 
     * @type {object}
     * @memberof UpdateUserDto
     */
    'friendship'?: object;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_picture_url': string;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'followers': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'following': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'links': object;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio': string;
    /**
     * 
     * @type {SongInfoDto}
     * @memberof UserDto
     */
    'current_song': SongInfoDto;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_genres': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_songs': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'fav_rooms': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'recent_rooms': object;
    /**
     * 
     * @type {object}
     * @memberof UserDto
     */
    'friendship': object;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate a user using the Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginBody: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginBody' is not null or undefined
            assertParamExists('authControllerLogin', 'loginBody', loginBody)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (refreshBody: RefreshBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshBody' is not null or undefined
            assertParamExists('authControllerRefresh', 'refreshBody', refreshBody)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerBody: RegisterBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerBody' is not null or undefined
            assertParamExists('authControllerRegister', 'registerBody', registerBody)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Callback for Spotify Auth
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyAuthCallback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('spotifyAuthControllerHandleSpotifyAuthCallback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('spotifyAuthControllerHandleSpotifyAuthCallback', 'state', state)
            const localVarPath = `/auth/spotify/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Manually Refresh Spotify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Spotify OAuth Redirect
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerPerformRedirect: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('spotifyAuthControllerPerformRedirect', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('spotifyAuthControllerPerformRedirect', 'state', state)
            const localVarPath = `/auth/spotify/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate a user using the Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginBody: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(refreshBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerBody: RegisterBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Callback for Spotify Auth
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyAuthControllerHandleSpotifyAuthCallback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyAuthControllerHandleSpotifyAuthCallback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyAuthControllerHandleSpotifyAuthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Manually Refresh Spotify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyAuthControllerHandleSpotifyRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyAuthControllerHandleSpotifyRefresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyAuthControllerHandleSpotifyRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyAuthControllerHandleSpotifyTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyAuthControllerHandleSpotifyTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyAuthControllerHandleSpotifyTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Spotify OAuth Redirect
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyAuthControllerPerformRedirect(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyAuthControllerPerformRedirect(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyAuthControllerPerformRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate a user using the Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginBody: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authControllerLogin(loginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authControllerRefresh(refreshBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerBody: RegisterBody, options?: RawAxiosRequestConfig): AxiosPromise<RegisterBody> {
            return localVarFp.authControllerRegister(registerBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Callback for Spotify Auth
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyAuthCallback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.spotifyAuthControllerHandleSpotifyAuthCallback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Manually Refresh Spotify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyRefresh(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenResponse> {
            return localVarFp.spotifyAuthControllerHandleSpotifyRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerHandleSpotifyTokens(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenResponse> {
            return localVarFp.spotifyAuthControllerHandleSpotifyTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Spotify OAuth Redirect
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyAuthControllerPerformRedirect(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.spotifyAuthControllerPerformRedirect(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate a user using the Cognito JWT token
     * @param {LoginBody} loginBody Cognito JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginBody: LoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh an expired (or almost expired) JWT token
     * @param {RefreshBody} refreshBody The expired JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefresh(refreshBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user in the API using Cognito
     * @param {RegisterBody} registerBody User info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRegister(registerBody: RegisterBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRegister(registerBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Callback for Spotify Auth
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyAuthControllerHandleSpotifyAuthCallback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyAuthControllerHandleSpotifyAuthCallback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Manually Refresh Spotify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyAuthControllerHandleSpotifyRefresh(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyAuthControllerHandleSpotifyRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Spotify Auth Tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyAuthControllerHandleSpotifyTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyAuthControllerHandleSpotifyTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Spotify OAuth Redirect
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyAuthControllerPerformRedirect(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyAuthControllerPerformRedirect(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerUploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerUploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.appControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Hello World!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file to our AWS S3 storage bucket
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerUploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async genresControllerGetAllGenres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.genresControllerGetAllGenres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.genresControllerGetAllGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenresApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.genresControllerGetAllGenres(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @summary Get all genres
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public genresControllerGetAllGenres(options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).genresControllerGetAllGenres(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerAddSongToQueue: async (roomID: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerAddSongToQueue', 'roomID', roomID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('roomsControllerAddSongToQueue', 'body', body)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerArchiveRoomSongs: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerArchiveRoomSongs', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/archive/playlist`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerBookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerBookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/bookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerClearRoomQueue: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerClearRoomQueue', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteArchivedSongs: async (playlistID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('roomsControllerDeleteArchivedSongs', 'playlistID', playlistID)
            const localVarPath = `/rooms/archive/playlist/{playlistID}`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerDeleteRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetArchivedSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/archive/playlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetCurrentRoom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/current/room`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetCurrentSong: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetCurrentSong', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs/current`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetKeyMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/analytics/keymetrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room\'s chat history
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetLiveChatHistory: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetLiveChatHistory', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/chat/history`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetNewRooms: async (none: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'none' is not null or undefined
            assertParamExists('roomsControllerGetNewRooms', 'none', none)
            const localVarPath = `/rooms/new`
                .replace(`{${"none"}}`, encodeURIComponent(String(none)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room contributor analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomContributorsAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomContributorsAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/contributors`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room info
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomInfo: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomInfo', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room interaction analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomInteractionAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomInteractionAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/interactions`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room participation analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomParticipationAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomParticipationAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/participation`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the queue of a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomQueue: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomQueue', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room queue analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomQueueAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomQueueAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/queue`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room song analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomSongsAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomSongsAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users in a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomUsers: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomUsers', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/users`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room voting analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomVotesAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerGetRoomVotesAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/votes`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerJoinRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerJoinRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/join`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerLeaveRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerLeaveRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/leave`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUnbookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerUnbookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/unbookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUpdateRoom: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerUpdateRoom', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('roomsControllerUpdateRoom', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUpdateRoomInfo: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('roomsControllerUpdateRoomInfo', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('roomsControllerUpdateRoomInfo', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerAddSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerAddSongToQueue(roomID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerAddSongToQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerArchiveRoomSongs(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerArchiveRoomSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerBookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerBookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerBookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerClearRoomQueue(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerClearRoomQueue(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerClearRoomQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerDeleteArchivedSongs(playlistID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerDeleteArchivedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerDeleteRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerDeleteRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerDeleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetArchivedSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetArchivedSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetCurrentRoom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetCurrentRoom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetCurrentRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetCurrentSong(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetCurrentSong(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetCurrentSong']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetKeyMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetKeyMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetKeyMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room\'s chat history
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveChatMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetLiveChatHistory(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetLiveChatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetNewRooms(none: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetNewRooms(none, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetNewRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room contributor analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomContributorsAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomContributorsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room info
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomInfo(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomInfo(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room interaction analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomInteractionAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomInteractionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room participation analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomParticipationAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomParticipationAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the queue of a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomQueue(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomQueue(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room queue analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomQueueAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomQueueAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room song analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomSongsAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomSongsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get users in a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomUsers(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomUsers(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get room voting analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerGetRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerGetRoomVotesAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerGetRoomVotesAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerJoinRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerJoinRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerJoinRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Leave a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerLeaveRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerLeaveRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerLeaveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unbookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerUnbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerUnbookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerUnbookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerUpdateRoom(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerUpdateRoom(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerUpdateRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomsControllerUpdateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomsControllerUpdateRoomInfo(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomsControllerUpdateRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a song to the queue of a room
         * @param {string} roomID 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerAddSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerAddSongToQueue(roomID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a room\'s songs
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerArchiveRoomSongs(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerBookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerBookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerClearRoomQueue(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerClearRoomQueue(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user\'s archived songs
         * @param {string} playlistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerDeleteArchivedSongs(playlistID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerDeleteRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.roomsControllerDeleteRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s archived songs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetArchivedSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetCurrentRoom(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetCurrentRoom(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetCurrentSong(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetCurrentSong(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get key metrics for user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetKeyMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetKeyMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room\'s chat history
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveChatMessageDto>> {
            return localVarFp.roomsControllerGetLiveChatHistory(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get newly created public rooms
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetNewRooms(none: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.roomsControllerGetNewRooms(none, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room contributor analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomContributorsAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room info
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomInfo(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.roomsControllerGetRoomInfo(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room interaction analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomInteractionAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room participation analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomParticipationAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the queue of a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomQueue(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomQueue(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room queue analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomQueueAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room song analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomSongsAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users in a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomUsers(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.roomsControllerGetRoomUsers(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room voting analytics
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerGetRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerGetRoomVotesAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerJoinRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.roomsControllerJoinRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerLeaveRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.roomsControllerLeaveRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unbookmark a room
         * @param {string} roomID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUnbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerUnbookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUpdateRoom(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomsControllerUpdateRoom(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID 
         * @param {UpdateRoomDto} updateRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsControllerUpdateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.roomsControllerUpdateRoomInfo(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 
     * @summary Add a song to the queue of a room
     * @param {string} roomID 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerAddSongToQueue(roomID: string, body: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerAddSongToQueue(roomID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a room\'s songs
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerArchiveRoomSongs(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerArchiveRoomSongs(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bookmark a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerBookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerBookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerClearRoomQueue(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerClearRoomQueue(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user\'s archived songs
     * @param {string} playlistID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerDeleteArchivedSongs(playlistID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerDeleteArchivedSongs(playlistID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerDeleteRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerDeleteRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s archived songs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetArchivedSongs(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetArchivedSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s current room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetCurrentRoom(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetCurrentRoom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetCurrentSong(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetCurrentSong(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get key metrics for user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetKeyMetrics(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetKeyMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room\'s chat history
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetLiveChatHistory(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get newly created public rooms
     * @param {any} none 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetNewRooms(none: any, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetNewRooms(none, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room contributor analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomContributorsAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomContributorsAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room info
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomInfo(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomInfo(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room interaction analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomInteractionAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room participation analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomParticipationAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the queue of a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomQueue(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomQueue(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room queue analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomQueueAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomQueueAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room song analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomSongsAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomSongsAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users in a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomUsers(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomUsers(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room voting analytics
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerGetRoomVotesAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerGetRoomVotesAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerJoinRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerJoinRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerLeaveRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerLeaveRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unbookmark a room
     * @param {string} roomID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerUnbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerUnbookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomID 
     * @param {UpdateRoomDto} updateRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerUpdateRoom(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerUpdateRoom(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room info
     * @param {string} roomID 
     * @param {UpdateRoomDto} updateRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomsControllerUpdateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomsControllerUpdateRoomInfo(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerAdvancedSearchRooms: async (q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerAdvancedSearchRooms', 'q', q)
            const localVarPath = `/search/rooms/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (participantCount !== undefined) {
                localVarQueryParameter['participant_count'] = participantCount;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (isTemp !== undefined) {
                localVarQueryParameter['is_temp'] = isTemp;
            }

            if (isPriv !== undefined) {
                localVarQueryParameter['is_priv'] = isPriv;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['is_scheduled'] = isScheduled;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['explicit'] = explicit;
            }

            if (nsfw !== undefined) {
                localVarQueryParameter['nsfw'] = nsfw;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerAdvancedSearchUsers: async (q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerAdvancedSearchUsers', 'q', q)
            const localVarPath = `/search/users/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            if (followers !== undefined) {
                localVarQueryParameter['followers'] = followers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearSearchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerCombinedSearch: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerCombinedSearch', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchRooms: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerSearchRooms', 'q', q)
            const localVarPath = `/search/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchUsers: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerSearchUsers', 'q', q)
            const localVarPath = `/search/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerAdvancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerAdvancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerAdvancedSearchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerAdvancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerAdvancedSearchUsers(q, creatorUsername, creatorName, following, followers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerAdvancedSearchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerClearRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerClearRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerClearRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerClearSearchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerClearSearchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerClearSearchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerClearUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerClearUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerClearUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerCombinedSearch(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerCombinedSearch(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerCombinedSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CombinedSearchHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerSearchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearchRooms(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerSearchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearchRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearchRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerSearchRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearchUsers(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearchUsers(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerSearchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearchUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearchUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchControllerSearchUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerAdvancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.searchControllerAdvancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerAdvancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.searchControllerAdvancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchControllerClearRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearSearchHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchControllerClearSearchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerClearUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchControllerClearUsersHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerCombinedSearch(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<CombinedSearchResults> {
            return localVarFp.searchControllerCombinedSearch(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<CombinedSearchHistory>> {
            return localVarFp.searchControllerSearchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchControllerSearchRooms(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchControllerSearchRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchUsers(q: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.searchControllerSearchUsers(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearchUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchControllerSearchUsersHistory(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Advanced search for rooms
     * @param {string} q A room name
     * @param {string} [creatorUsername] A room creator\&#39;s username
     * @param {string} [creatorName] A room creator\&#39;s profile name
     * @param {number} [participantCount] Minimum number of participants
     * @param {string} [description] A string to find in the room description
     * @param {boolean} [isTemp] Is the room temporary?
     * @param {boolean} [isPriv] Is the room private?
     * @param {boolean} [isScheduled] Is the room scheduled?
     * @param {string} [startDate] Only if scheduled, the start date
     * @param {string} [endDate] Only if scheduled, the end date
     * @param {string} [lang] The room language (as a ISO 639-1 code)
     * @param {boolean} [explicit] Is the room explicit?
     * @param {boolean} [nsfw] Is the room NSFW?
     * @param {string} [tags] A comma separated list of tags to compare
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerAdvancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerAdvancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Advanced search for users
     * @param {string} q A username or profile name
     * @param {string} [creatorUsername] A user\&#39;s username
     * @param {string} [creatorName] A user\&#39;s profile name
     * @param {number} [following] Minimum number of following
     * @param {number} [followers] Minimum number of followers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerAdvancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerAdvancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear room search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerClearRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerClearRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerClearSearchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerClearSearchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear user search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerClearUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerClearUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for rooms and users
     * @param {string} q A room name / username
     * @param {string} [creator] A room creator\&#39;s profile name or username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerCombinedSearch(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerCombinedSearch(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get search history (including objects discovered from search)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for rooms
     * @param {string} q A room name
     * @param {string} [creator] A room creator\&#39;s profile name / username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearchRooms(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recently searched rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearchRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearchRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users
     * @param {string} q A username or profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearchUsers(q: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearchUsers(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recently searched users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearchUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearchUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAcceptFriendRequest: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerAcceptFriendRequest', 'userID', userID)
            const localVarPath = `/users/{userID}/accept`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAcceptFriendRequest_1: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerAcceptFriendRequest_1', 'userID', userID)
            const localVarPath = `/users/{userID}/accept`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBefriendUser: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerBefriendUser', 'userID', userID)
            const localVarPath = `/users/{userID}/befriend`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBefriendUser_2: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerBefriendUser_2', 'userID', userID)
            const localVarPath = `/users/{userID}/befriend`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateRoom: async (createRoomDto: CreateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDto' is not null or undefined
            assertParamExists('usersControllerCreateRoom', 'createRoomDto', createRoomDto)
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateRoom_3: async (createRoomDto: CreateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDto' is not null or undefined
            assertParamExists('usersControllerCreateRoom_3', 'createRoomDto', createRoomDto)
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFollowUser: async (userID: string, username: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerFollowUser', 'userID', userID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerFollowUser', 'username', username)
            const localVarPath = `/users/{userID}/follow`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFollowUser_4: async (userID: string, username: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerFollowUser_4', 'userID', userID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerFollowUser_4', 'username', username)
            const localVarPath = `/users/{userID}/follow`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetBookmarks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetBookmarks_5: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoom_6: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetDMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/dms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetDMs_7: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/dms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowers: async (none: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'none' is not null or undefined
            assertParamExists('usersControllerGetFollowers', 'none', none)
            const localVarPath = `/users/followers`
                .replace(`{${"none"}}`, encodeURIComponent(String(none)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowers_8: async (none: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'none' is not null or undefined
            assertParamExists('usersControllerGetFollowers_8', 'none', none)
            const localVarPath = `/users/followers`
                .replace(`{${"none"}}`, encodeURIComponent(String(none)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowing_9: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFriendRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFriendRequests_10: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfileByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerGetProfileByUsername', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfileByUsername_11: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerGetProfileByUsername_11', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile_12: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile_13: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecentRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecentRooms_14: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedRooms_15: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserFriends: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserFriends_16: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserRooms_17: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPatchProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerPatchProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPatchProfile_18: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerPatchProfile_18', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPutProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerPutProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPutProfile_19: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerPutProfile_19', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRejectFriendRequest: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerRejectFriendRequest', 'userID', userID)
            const localVarPath = `/users/{userID}/reject`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRejectFriendRequest_20: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerRejectFriendRequest_20', 'userID', userID)
            const localVarPath = `/users/{userID}/reject`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfollowUser: async (userID: string, username: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerUnfollowUser', 'userID', userID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerUnfollowUser', 'username', username)
            const localVarPath = `/users/{userID}/unfollow`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfollowUser_21: async (userID: string, username: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerUnfollowUser_21', 'userID', userID)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerUnfollowUser_21', 'username', username)
            const localVarPath = `/users/{userID}/unfollow`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfriendUser: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerUnfriendUser', 'userID', userID)
            const localVarPath = `/users/{userID}/unfriend`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfriendUser_22: async (userID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('usersControllerUnfriendUser_22', 'userID', userID)
            const localVarPath = `/users/{userID}/unfriend`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerAcceptFriendRequest(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerAcceptFriendRequest(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerAcceptFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerAcceptFriendRequest_1(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerAcceptFriendRequest_1(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerAcceptFriendRequest_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerBefriendUser(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerBefriendUser(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerBefriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerBefriendUser_2(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerBefriendUser_2(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerBefriendUser_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreateRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreateRoom(createRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerCreateRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreateRoom_3(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreateRoom_3(createRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerCreateRoom_3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFollowUser(userID: string, username: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFollowUser(userID, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFollowUser_4(userID: string, username: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFollowUser_4(userID, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFollowUser_4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetBookmarks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetBookmarks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetBookmarks_5(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetBookmarks_5(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetBookmarks_5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetCurrentRoom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetCurrentRoom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetCurrentRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetCurrentRoom_6(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetCurrentRoom_6(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetCurrentRoom_6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetDMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetDMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetDMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetDMs_7(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetDMs_7(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetDMs_7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFollowers(none: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFollowers(none, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFollowers_8(none: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFollowers_8(none, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFollowers_8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFollowing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFollowing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFollowing_9(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFollowing_9(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFollowing_9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFriendRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFriendRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFriendRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetFriendRequests_10(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetFriendRequests_10(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetFriendRequests_10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetProfileByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetProfileByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetProfileByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetProfileByUsername_11(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetProfileByUsername_11(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetProfileByUsername_11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetProfile_12(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetProfile_12(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetProfile_12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetProfile_13(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetProfile_13(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetProfile_13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecentRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecentRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecentRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecentRooms_14(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecentRooms_14(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecentRooms_14']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecommendedRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecommendedRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecommendedRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecommendedRooms_15(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecommendedRooms_15(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecommendedRooms_15']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserFriends(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserFriends(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserFriends_16(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserFriends_16(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUserFriends_16']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUserRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserRooms_17(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserRooms_17(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUserRooms_17']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerPatchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerPatchProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerPatchProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerPatchProfile_18(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerPatchProfile_18(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerPatchProfile_18']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerPutProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerPutProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerPutProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerPutProfile_19(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerPutProfile_19(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerPutProfile_19']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRejectFriendRequest(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRejectFriendRequest(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerRejectFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRejectFriendRequest_20(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRejectFriendRequest_20(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerRejectFriendRequest_20']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUnfollowUser(userID: string, username: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUnfollowUser(userID, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerUnfollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUnfollowUser_21(userID: string, username: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUnfollowUser_21(userID, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerUnfollowUser_21']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUnfriendUser(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUnfriendUser(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerUnfriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUnfriendUser_22(userID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUnfriendUser_22(userID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerUnfriendUser_22']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAcceptFriendRequest(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerAcceptFriendRequest(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAcceptFriendRequest_1(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerAcceptFriendRequest_1(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBefriendUser(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerBefriendUser(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a friend request to the given user
         * @param {string} userID The userID of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBefriendUser_2(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerBefriendUser_2(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerCreateRoom(createRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateRoom_3(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerCreateRoom_3(createRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFollowUser(userID: string, username: any, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerFollowUser(userID, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFollowUser_4(userID: string, username: any, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerFollowUser_4(userID, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetBookmarks(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetBookmarks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetBookmarks_5(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetBookmarks_5(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoom(options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerGetCurrentRoom(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s current room (room that they are currently in)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoom_6(options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerGetCurrentRoom_6(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetDMs(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.usersControllerGetDMs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetDMs_7(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.usersControllerGetDMs_7(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowers(none: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFollowers(none, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s followers
         * @param {any} none 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowers_8(none: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFollowers_8(none, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowing(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFollowing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFollowing_9(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFollowing_9(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFriendRequests(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFriendRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetFriendRequests_10(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetFriendRequests_10(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfileByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerGetProfileByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfileByUsername_11(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerGetProfileByUsername_11(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile_12(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerGetProfile_12(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetProfile_13(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerGetProfile_13(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecentRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetRecentRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecentRooms_14(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetRecentRooms_14(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetRecommendedRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedRooms_15(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetRecommendedRooms_15(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetUserFriends(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserFriends_16(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetUserFriends_16(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetUserRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserRooms_17(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.usersControllerGetUserRooms_17(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPatchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerPatchProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPatchProfile_18(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerPatchProfile_18(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPutProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerPutProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerPutProfile_19(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.usersControllerPutProfile_19(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRejectFriendRequest(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerRejectFriendRequest(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a friend request from the given user
         * @param {string} userID The userID of the user whose friend request to reject.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRejectFriendRequest_20(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerRejectFriendRequest_20(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfollowUser(userID: string, username: any, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerUnfollowUser(userID, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow the given user
         * @param {string} userID 
         * @param {any} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfollowUser_21(userID: string, username: any, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerUnfollowUser_21(userID, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfriendUser(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerUnfriendUser(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary End friendship with the given user
         * @param {string} userID The userID of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUnfriendUser_22(userID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.usersControllerUnfriendUser_22(userID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Accept a friend request from the given user
     * @param {string} userID The userID of the user whose friend request to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerAcceptFriendRequest(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerAcceptFriendRequest(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept a friend request from the given user
     * @param {string} userID The userID of the user whose friend request to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerAcceptFriendRequest_1(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerAcceptFriendRequest_1(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a friend request to the given user
     * @param {string} userID The userID of the user to send a friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerBefriendUser(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerBefriendUser(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a friend request to the given user
     * @param {string} userID The userID of the user to send a friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerBefriendUser_2(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerBefriendUser_2(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new room
     * @param {CreateRoomDto} createRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreateRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreateRoom(createRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new room
     * @param {CreateRoomDto} createRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreateRoom_3(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreateRoom_3(createRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow the given user
     * @param {string} userID 
     * @param {any} username The username of the user to follow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFollowUser(userID: string, username: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFollowUser(userID, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow the given user
     * @param {string} userID 
     * @param {any} username The username of the user to follow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFollowUser_4(userID: string, username: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFollowUser_4(userID, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the authorized user\'s bookmarks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetBookmarks(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetBookmarks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the authorized user\'s bookmarks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetBookmarks_5(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetBookmarks_5(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s current room (room that they are currently in)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetCurrentRoom(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetCurrentRoom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s current room (room that they are currently in)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetCurrentRoom_6(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetCurrentRoom_6(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the last DMs sent to or received from another user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetDMs(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetDMs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the last DMs sent to or received from another user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetDMs_7(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetDMs_7(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s followers
     * @param {any} none 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFollowers(none: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFollowers(none, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s followers
     * @param {any} none 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFollowers_8(none: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFollowers_8(none, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFollowing(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFollowing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFollowing_9(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFollowing_9(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFriendRequests(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFriendRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetFriendRequests_10(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetFriendRequests_10(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user\'s profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetProfile(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile info by username
     * @param {string} username The username of the user to fetch profile info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetProfileByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetProfileByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile info by username
     * @param {string} username The username of the user to fetch profile info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetProfileByUsername_11(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetProfileByUsername_11(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user\'s profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetProfile_12(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetProfile_12(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user\'s profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetProfile_13(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetProfile_13(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s recent rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecentRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecentRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s recent rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecentRooms_14(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecentRooms_14(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s recommended rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecommendedRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecommendedRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s recommended rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecommendedRooms_15(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecommendedRooms_15(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friends
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserFriends(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserFriends(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friends
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserFriends_16(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserFriends_16(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserRooms_17(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserRooms_17(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerPatchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerPatchProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerPatchProfile_18(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerPatchProfile_18(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerPutProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerPutProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerPutProfile_19(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerPutProfile_19(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a friend request from the given user
     * @param {string} userID The userID of the user whose friend request to reject.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRejectFriendRequest(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRejectFriendRequest(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a friend request from the given user
     * @param {string} userID The userID of the user whose friend request to reject.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRejectFriendRequest_20(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRejectFriendRequest_20(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow the given user
     * @param {string} userID 
     * @param {any} username The username of the user to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUnfollowUser(userID: string, username: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUnfollowUser(userID, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow the given user
     * @param {string} userID 
     * @param {any} username The username of the user to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUnfollowUser_21(userID: string, username: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUnfollowUser_21(userID, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary End friendship with the given user
     * @param {string} userID The userID of the user to end friendship with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUnfriendUser(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUnfriendUser(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary End friendship with the given user
     * @param {string} userID The userID of the user to end friendship with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUnfriendUser_22(userID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUnfriendUser_22(userID, options).then((request) => request(this.axios, this.basePath));
    }
}



