/* tslint:disable */
/* eslint-disable */
/**
 * TuneIn API
 * The API for the TuneIn application, handling all the backend logic and making it available to the frontend.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Average session duration in the user\'s rooms
 * @export
 * @interface AverageSessionDuration
 */
export interface AverageSessionDuration {
    /**
     * 
     * @type {number}
     * @memberof AverageSessionDuration
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AverageSessionDuration
     */
    'percentage_change'?: number;
}
/**
 * 
 * @export
 * @interface CombinedSearchHistory
 */
export interface CombinedSearchHistory {
    /**
     * Mixed list of rooms, users, or strings
     * @type {Array<object>}
     * @memberof CombinedSearchHistory
     */
    'results': Array<object>;
}
/**
 * 
 * @export
 * @interface CombinedSearchResults
 */
export interface CombinedSearchResults {
    /**
     * List of rooms
     * @type {Array<RoomDto>}
     * @memberof CombinedSearchResults
     */
    'rooms': Array<RoomDto>;
    /**
     * List of users
     * @type {Array<UserDto>}
     * @memberof CombinedSearchResults
     */
    'users': Array<UserDto>;
}
/**
 * 
 * @export
 * @interface CreateRoomDto
 */
export interface CreateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_temporary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'is_scheduled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_explicit_content'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomDto
     */
    'has_nsfw_content'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDto
     */
    'room_image'?: string;
    /**
     * The tags that describe the room
     * @type {Array<string>}
     * @memberof CreateRoomDto
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface DirectMessageDto
 */
export interface DirectMessageDto {
    /**
     * 
     * @type {number}
     * @memberof DirectMessageDto
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof DirectMessageDto
     */
    'messageBody': string;
    /**
     * The sender of the message
     * @type {UserDto}
     * @memberof DirectMessageDto
     */
    'sender': UserDto;
    /**
     * The recipient of the message
     * @type {UserDto}
     * @memberof DirectMessageDto
     */
    'recipient': UserDto;
    /**
     * 
     * @type {string}
     * @memberof DirectMessageDto
     */
    'dateSent': string;
    /**
     * 
     * @type {string}
     * @memberof DirectMessageDto
     */
    'dateRead': string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectMessageDto
     */
    'isRead': boolean;
    /**
     * 
     * @type {string}
     * @memberof DirectMessageDto
     */
    'pID': string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectMessageDto
     */
    'bodyIsRoomID': boolean;
}
/**
 * 
 * @export
 * @interface FollowersAndFollowing
 */
export interface FollowersAndFollowing {
    /**
     * 
     * @type {number}
     * @memberof FollowersAndFollowing
     */
    'count': number;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof FollowersAndFollowing
     */
    'data': Array<UserDto>;
}
/**
 * 
 * @export
 * @interface GenresWithCount
 */
export interface GenresWithCount {
    /**
     * 
     * @type {number}
     * @memberof GenresWithCount
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GenresWithCount
     */
    'data': Array<string>;
}
/**
 * Join statistics, including total and unique joins per day and all-time
 * @export
 * @interface Joins
 */
export interface Joins {
    /**
     * 
     * @type {object}
     * @memberof Joins
     */
    'per_day'?: object;
    /**
     * 
     * @type {JoinsAllTime}
     * @memberof Joins
     */
    'all_time'?: JoinsAllTime;
}
/**
 * 
 * @export
 * @interface JoinsAllTime
 */
export interface JoinsAllTime {
    /**
     * 
     * @type {number}
     * @memberof JoinsAllTime
     */
    'total_joins'?: number;
    /**
     * 
     * @type {number}
     * @memberof JoinsAllTime
     */
    'unique_joins'?: number;
}
/**
 * 
 * @export
 * @interface LinksWithCount
 */
export interface LinksWithCount {
    /**
     * 
     * @type {number}
     * @memberof LinksWithCount
     */
    'count': number;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof LinksWithCount
     */
    'data': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface LiveChatMessageDto
 */
export interface LiveChatMessageDto {
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'messageID': string;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'messageBody': string;
    /**
     * 
     * @type {UserDto}
     * @memberof LiveChatMessageDto
     */
    'sender': UserDto;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'roomID': string;
    /**
     * 
     * @type {string}
     * @memberof LiveChatMessageDto
     */
    'dateCreated'?: string;
}
/**
 * 
 * @export
 * @interface LoginBody
 */
export interface LoginBody {
    /**
     * The Cognito JWT token
     * @type {string}
     * @memberof LoginBody
     */
    'token': string;
}
/**
 * Total messages sent and messages sent per hour
 * @export
 * @interface Messages
 */
export interface Messages {
    /**
     * 
     * @type {number}
     * @memberof Messages
     */
    'total'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Messages
     */
    'per_hour'?: Array<object>;
}
/**
 * 
 * @export
 * @interface ParticipantsPerHourDto
 */
export interface ParticipantsPerHourDto {
    /**
     * The number of participants in the room at the given hour
     * @type {number}
     * @memberof ParticipantsPerHourDto
     */
    'count': number;
    /**
     * The specific hour for participant count
     * @type {string}
     * @memberof ParticipantsPerHourDto
     */
    'instance': string;
}
/**
 * 
 * @export
 * @interface RefreshBody
 */
export interface RefreshBody {
    /**
     * The JWT token to be refreshed
     * @type {string}
     * @memberof RefreshBody
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterBody
 */
export interface RegisterBody {
    /**
     * The user\'s username
     * @type {string}
     * @memberof RegisterBody
     */
    'username': string;
    /**
     * The user\'s Cognito sub/ID
     * @type {string}
     * @memberof RegisterBody
     */
    'userCognitoSub': string;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterBody
     */
    'email': string;
}
/**
 * Expected return visits and probability of return
 * @export
 * @interface ReturnVisits
 */
export interface ReturnVisits {
    /**
     * 
     * @type {number}
     * @memberof ReturnVisits
     */
    'expected_return_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReturnVisits
     */
    'probability_of_return'?: number;
}
/**
 * Returning visitors to the user\'s rooms
 * @export
 * @interface ReturningVisitors
 */
export interface ReturningVisitors {
    /**
     * 
     * @type {number}
     * @memberof ReturningVisitors
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReturningVisitors
     */
    'percentage_change'?: number;
}
/**
 * 
 * @export
 * @interface RoomAnalyticsInteractionsDto
 */
export interface RoomAnalyticsInteractionsDto {
    /**
     * 
     * @type {Messages}
     * @memberof RoomAnalyticsInteractionsDto
     */
    'messages': Messages;
    /**
     * Total number of reactions sent in the room
     * @type {number}
     * @memberof RoomAnalyticsInteractionsDto
     */
    'reactions_sent': number;
    /**
     * Number of times the room was bookmarked
     * @type {number}
     * @memberof RoomAnalyticsInteractionsDto
     */
    'bookmarked_count': number;
}
/**
 * 
 * @export
 * @interface RoomAnalyticsKeyMetricsDto
 */
export interface RoomAnalyticsKeyMetricsDto {
    /**
     * 
     * @type {UniqueVisitors}
     * @memberof RoomAnalyticsKeyMetricsDto
     */
    'unique_visitors': UniqueVisitors;
    /**
     * 
     * @type {ReturningVisitors}
     * @memberof RoomAnalyticsKeyMetricsDto
     */
    'returning_visitors': ReturningVisitors;
    /**
     * 
     * @type {AverageSessionDuration}
     * @memberof RoomAnalyticsKeyMetricsDto
     */
    'average_session_duration': AverageSessionDuration;
}
/**
 * 
 * @export
 * @interface RoomAnalyticsParticipationDto
 */
export interface RoomAnalyticsParticipationDto {
    /**
     * 
     * @type {Joins}
     * @memberof RoomAnalyticsParticipationDto
     */
    'joins': Joins;
    /**
     * Participants per hour data
     * @type {Array<ParticipantsPerHourDto>}
     * @memberof RoomAnalyticsParticipationDto
     */
    'participants_per_hour': Array<ParticipantsPerHourDto>;
    /**
     * 
     * @type {SessionData}
     * @memberof RoomAnalyticsParticipationDto
     */
    'session_data': SessionData;
    /**
     * 
     * @type {ReturnVisits}
     * @memberof RoomAnalyticsParticipationDto
     */
    'return_visits': ReturnVisits;
    /**
     * Number of previews of the room, i.e. without joining
     * @type {number}
     * @memberof RoomAnalyticsParticipationDto
     */
    'room_previews': number;
}
/**
 * 
 * @export
 * @interface RoomDto
 */
export interface RoomDto {
    /**
     * 
     * @type {UserDto}
     * @memberof RoomDto
     */
    'creator': UserDto;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'roomID': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'spotifyPlaylistID': string;
    /**
     * 
     * @type {number}
     * @memberof RoomDto
     */
    'participant_count': number;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_name': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_temporary': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'is_scheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'language': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_explicit_content': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDto
     */
    'has_nsfw_content': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomDto
     */
    'room_image': string;
    /**
     * The current song playing in the room
     * @type {RoomSongDto}
     * @memberof RoomDto
     */
    'current_song'?: RoomSongDto;
    /**
     * The tags that describe the room
     * @type {Array<string>}
     * @memberof RoomDto
     */
    'tags': Array<string>;
    /**
     * The parent of this room, if this room was created by splitting another
     * @type {string}
     * @memberof RoomDto
     */
    'parentRoomID'?: string;
    /**
     * Rooms created by splitting this room.
     * @type {Array<string>}
     * @memberof RoomDto
     */
    'childrenRoomIDs': Array<string>;
}
/**
 * 
 * @export
 * @interface RoomSongDto
 */
export interface RoomSongDto {
    /**
     * 
     * @type {string}
     * @memberof RoomSongDto
     */
    'spotifyID': string;
    /**
     * 
     * @type {string}
     * @memberof RoomSongDto
     */
    'userID': string;
    /**
     * 
     * @type {number}
     * @memberof RoomSongDto
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof RoomSongDto
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof RoomSongDto
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof RoomSongDto
     */
    'insertTime': string;
    /**
     * 
     * @type {string}
     * @memberof RoomSongDto
     */
    'pauseTime': string;
    /**
     * 
     * @type {object}
     * @memberof RoomSongDto
     */
    'track': object;
    /**
     * 
     * @type {number}
     * @memberof RoomSongDto
     */
    'playlistIndex': number;
}
/**
 * 
 * @export
 * @interface RoomsData
 */
export interface RoomsData {
    /**
     * 
     * @type {number}
     * @memberof RoomsData
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoomsData
     */
    'data': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchHistoryDto
 */
export interface SearchHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_term': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'search_time': string;
    /**
     * 
     * @type {string}
     * @memberof SearchHistoryDto
     */
    'url': string;
}
/**
 * Session data including average, minimum, and maximum duration all-time and per day
 * @export
 * @interface SessionData
 */
export interface SessionData {
    /**
     * 
     * @type {object}
     * @memberof SessionData
     */
    'all_time'?: object;
    /**
     * 
     * @type {Array<object>}
     * @memberof SessionData
     */
    'per_day'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SongInfoDto
 */
export interface SongInfoDto {
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'songID'?: string;
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'title': string;
    /**
     * The artists that performed the song
     * @type {Array<string>}
     * @memberof SongInfoDto
     */
    'artists': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'cover'?: string;
    /**
     * 
     * @type {number}
     * @memberof SongInfoDto
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof SongInfoDto
     */
    'spotify_id': string;
    /**
     * The time the song started playing
     * @type {string}
     * @memberof SongInfoDto
     */
    'start_time'?: string | null;
}
/**
 * 
 * @export
 * @interface SongInfosWithCount
 */
export interface SongInfosWithCount {
    /**
     * 
     * @type {number}
     * @memberof SongInfosWithCount
     */
    'count': number;
    /**
     * 
     * @type {Array<SongInfoDto>}
     * @memberof SongInfosWithCount
     */
    'data': Array<SongInfoDto>;
}
/**
 * 
 * @export
 * @interface SpotifyCallbackResponse
 */
export interface SpotifyCallbackResponse {
    /**
     * 
     * @type {string}
     * @memberof SpotifyCallbackResponse
     */
    'token': string;
    /**
     * 
     * @type {SpotifyTokenPair}
     * @memberof SpotifyCallbackResponse
     */
    'spotifyTokens': SpotifyTokenPair;
}
/**
 * 
 * @export
 * @interface SpotifyTokenPair
 */
export interface SpotifyTokenPair {
    /**
     * 
     * @type {SpotifyTokenResponse}
     * @memberof SpotifyTokenPair
     */
    'tokens': SpotifyTokenResponse;
    /**
     * 
     * @type {number}
     * @memberof SpotifyTokenPair
     */
    'epoch_expiry': number;
}
/**
 * 
 * @export
 * @interface SpotifyTokenResponse
 */
export interface SpotifyTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof SpotifyTokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof SpotifyTokenResponse
     */
    'refresh_token': string;
}
/**
 * Unique visitors to the user\'s rooms
 * @export
 * @interface UniqueVisitors
 */
export interface UniqueVisitors {
    /**
     * 
     * @type {number}
     * @memberof UniqueVisitors
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof UniqueVisitors
     */
    'percentage_change'?: number;
}
/**
 * 
 * @export
 * @interface UpdateRoomDto
 */
export interface UpdateRoomDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_temporary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'is_scheduled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_explicit_content'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoomDto
     */
    'has_nsfw_content'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDto
     */
    'room_image'?: string;
    /**
     * The tags that describe the room
     * @type {Array<string>}
     * @memberof UpdateRoomDto
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profile_picture_url'?: string;
    /**
     * The user\'s followers
     * @type {FollowersAndFollowing}
     * @memberof UpdateUserDto
     */
    'followers'?: FollowersAndFollowing;
    /**
     * The user\'s following
     * @type {FollowersAndFollowing}
     * @memberof UpdateUserDto
     */
    'following'?: FollowersAndFollowing;
    /**
     * The user\'s links
     * @type {LinksWithCount}
     * @memberof UpdateUserDto
     */
    'links'?: LinksWithCount;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'bio'?: string;
    /**
     * The current song the user is listening to, if applicable
     * @type {SongInfoDto}
     * @memberof UpdateUserDto
     */
    'current_song'?: SongInfoDto;
    /**
     * The roomID of the room that the user is currently in, if applicable
     * @type {string}
     * @memberof UpdateUserDto
     */
    'current_room_id'?: string;
    /**
     * The user\'s favorite genres
     * @type {GenresWithCount}
     * @memberof UpdateUserDto
     */
    'fav_genres'?: GenresWithCount;
    /**
     * The user\'s favorite songs
     * @type {SongInfosWithCount}
     * @memberof UpdateUserDto
     */
    'fav_songs'?: SongInfosWithCount;
    /**
     * The user\'s favorite rooms
     * @type {RoomsData}
     * @memberof UpdateUserDto
     */
    'fav_rooms'?: RoomsData;
    /**
     * The user\'s recent rooms
     * @type {RoomsData}
     * @memberof UpdateUserDto
     */
    'recent_rooms'?: RoomsData;
    /**
     * The user\'s friendship status with the current user, or null if the user is not friends with the current user
     * @type {UserFriendship}
     * @memberof UpdateUserDto
     */
    'friendship'?: UserFriendship;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'hasSpotifyAccount'?: boolean;
    /**
     * The relationship status between the current user and the user in question
     * @type {string}
     * @memberof UpdateUserDto
     */
    'relationship'?: string;
}
/**
 * 
 * @export
 * @interface UserActionDto
 */
export interface UserActionDto {
    /**
     * The user ID of the user that the action was performed on
     * @type {string}
     * @memberof UserActionDto
     */
    'userID': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'userID': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_picture_url': string;
    /**
     * The user\'s followers
     * @type {FollowersAndFollowing}
     * @memberof UserDto
     */
    'followers': FollowersAndFollowing;
    /**
     * The user\'s following
     * @type {FollowersAndFollowing}
     * @memberof UserDto
     */
    'following': FollowersAndFollowing;
    /**
     * The user\'s links
     * @type {LinksWithCount}
     * @memberof UserDto
     */
    'links': LinksWithCount;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio'?: string;
    /**
     * The current song the user is listening to, if applicable
     * @type {SongInfoDto}
     * @memberof UserDto
     */
    'current_song'?: SongInfoDto;
    /**
     * The roomID of the room that the user is currently in, if applicable
     * @type {string}
     * @memberof UserDto
     */
    'current_room_id'?: string;
    /**
     * The user\'s favorite genres
     * @type {GenresWithCount}
     * @memberof UserDto
     */
    'fav_genres': GenresWithCount;
    /**
     * The user\'s favorite songs
     * @type {SongInfosWithCount}
     * @memberof UserDto
     */
    'fav_songs': SongInfosWithCount;
    /**
     * The user\'s favorite rooms
     * @type {RoomsData}
     * @memberof UserDto
     */
    'fav_rooms': RoomsData;
    /**
     * The user\'s recent rooms
     * @type {RoomsData}
     * @memberof UserDto
     */
    'recent_rooms': RoomsData;
    /**
     * The user\'s friendship status with the current user, or null if the user is not friends with the current user
     * @type {UserFriendship}
     * @memberof UserDto
     */
    'friendship'?: UserFriendship;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    'hasSpotifyAccount': boolean;
    /**
     * The relationship status between the current user and the user in question
     * @type {string}
     * @memberof UserDto
     */
    'relationship'?: string;
}
/**
 * 
 * @export
 * @interface UserFriendship
 */
export interface UserFriendship {
    /**
     * 
     * @type {boolean}
     * @memberof UserFriendship
     */
    'status': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserFriendship
     */
    'accept_url': string;
    /**
     * 
     * @type {string}
     * @memberof UserFriendship
     */
    'reject_url': string;
}
/**
 * 
 * @export
 * @interface UserListeningStatsDto
 */
export interface UserListeningStatsDto {
    /**
     * The total number of songs listened to by the user
     * @type {number}
     * @memberof UserListeningStatsDto
     */
    'totalListenedSongs': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpotifyTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginBody: LoginBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginBody' is not null or undefined
            assertParamExists('login', 'loginBody', loginBody)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshBody: RefreshBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshBody' is not null or undefined
            assertParamExists('refresh', 'refreshBody', refreshBody)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSpotifyTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerBody: RegisterBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerBody' is not null or undefined
            assertParamExists('register', 'registerBody', registerBody)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyCallback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('spotifyCallback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('spotifyCallback', 'state', state)
            const localVarPath = `/auth/spotify/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpotifyTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpotifyTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getSpotifyTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginBody: LoginBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshSpotifyTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshSpotifyTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshSpotifyTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerBody: RegisterBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotifyCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyCallback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.spotifyCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Returns the user\'s Spotify Auth Tokens
         * @summary Get Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpotifyTokens(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenPair> {
            return localVarFp.getSpotifyTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
         * @summary Authenticate a user using a Cognito JWT token
         * @param {LoginBody} loginBody Cognito JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginBody: LoginBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.login(loginBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
         * @summary Refresh an expired (or almost expired) JWT token
         * @param {RefreshBody} refreshBody The expired JWT token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.refresh(refreshBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
         * @summary Manually Refresh Spotify Auth Tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSpotifyTokens(options?: RawAxiosRequestConfig): AxiosPromise<SpotifyTokenResponse> {
            return localVarFp.refreshSpotifyTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
         * @summary Register a new user in the API using Cognito
         * @param {RegisterBody} registerBody User\&#39;s Cognito information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerBody: RegisterBody, options?: RawAxiosRequestConfig): AxiosPromise<RegisterBody> {
            return localVarFp.register(registerBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
         * @summary Callback for Spotify Auth
         * @param {string} code The authorization code returned by Spotify after user consent
         * @param {string} state A unique state value to prevent CSRF attacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<SpotifyCallbackResponse> {
            return localVarFp.spotifyCallback(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Returns the user\'s Spotify Auth Tokens
     * @summary Get Spotify Auth Tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getSpotifyTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getSpotifyTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will authenticate a user using a Cognito JWT token. The token is decoded and verified, and a new JWT token is generated and returned. See https://jwt.io/ for more information on JWT tokens.
     * @summary Authenticate a user using a Cognito JWT token
     * @param {LoginBody} loginBody Cognito JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginBody: LoginBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will refresh an expired (or almost expired) JWT token. The expired token is sent in the request body, and a new JWT token is generated and returned. The new token will have a new expiration date.
     * @summary Refresh an expired (or almost expired) JWT token
     * @param {RefreshBody} refreshBody The expired JWT token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refresh(refreshBody: RefreshBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refresh(refreshBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will manually refresh the user\'s Spotify Auth Tokens and return the new tokens
     * @summary Manually Refresh Spotify Auth Tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshSpotifyTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshSpotifyTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will register a new user in the API using Cognito. The user\'s Cognito username, email, and Cognito sub ID are required. The user will be created in the our database and will be able to authenticate using the Cognito JWT token.
     * @summary Register a new user in the API using Cognito
     * @param {RegisterBody} registerBody User\&#39;s Cognito information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerBody: RegisterBody, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles the Spotify auth callback, creates an account for the user (if necessary), authenticates the user, and returns a JWT token
     * @summary Callback for Spotify Auth
     * @param {string} code The authorization code returned by Spotify after user consent
     * @param {string} state A unique state value to prevent CSRF attacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public spotifyCallback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).spotifyCallback(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Hello World!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getHello(options).then((request) => request(axios, basePath));
        },
        /**
         * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
         * @summary Upload a file to our AWS S3 storage bucket
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Hello World!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation uploads a file to AWS S3 (the TuneIn bucket) and returns the URL of the uploaded file.
     * @summary Upload a file to our AWS S3 storage bucket
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all genres
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenresApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all genres
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async genresControllerGetAllGenres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.genresControllerGetAllGenres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.genresControllerGetAllGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenresApiFp(configuration)
    return {
        /**
         * Returns a list of all genres
         * @summary Get all genres
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        genresControllerGetAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.genresControllerGetAllGenres(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * Returns a list of all genres
     * @summary Get all genres
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public genresControllerGetAllGenres(options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).genresControllerGetAllGenres(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomAnalyticsApi - axios parameter creator
 * @export
 */
export const RoomAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {string} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyMetrics: async (period: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getKeyMetrics', 'period', period)
            const localVarPath = `/rooms/analytics/{period}/keymetrics`
                .replace(`{${"period"}}`, encodeURIComponent(String(period)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInteractionAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomInteractionAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/interactions`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomParticipationAnalytics: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomParticipationAnalytics', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/analytics/participation`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomAnalyticsApi - functional programming interface
 * @export
 */
export const RoomAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {string} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyMetrics(period: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomAnalyticsKeyMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyMetrics(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getKeyMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomAnalyticsInteractionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomInteractionAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomInteractionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomAnalyticsParticipationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomParticipationAnalytics(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomAnalyticsApi.getRoomParticipationAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomAnalyticsApi - factory interface
 * @export
 */
export const RoomAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomAnalyticsApiFp(configuration)
    return {
        /**
         * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
         * @summary Get key metrics for user\'s rooms
         * @param {string} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyMetrics(period: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomAnalyticsKeyMetricsDto> {
            return localVarFp.getKeyMetrics(period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
         * @summary Get room interaction analytics
         * @param {string} roomID The ID of the room to get interaction analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomAnalyticsInteractionsDto> {
            return localVarFp.getRoomInteractionAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
         * @summary Get room participation analytics
         * @param {string} roomID The ID of the room to get participation analytics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomAnalyticsParticipationDto> {
            return localVarFp.getRoomParticipationAnalytics(roomID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomAnalyticsApi - object-oriented interface
 * @export
 * @class RoomAnalyticsApi
 * @extends {BaseAPI}
 */
export class RoomAnalyticsApi extends BaseAPI {
    /**
     * Returns the key metrics for the user\'s rooms as a RoomAnalyticsKeyMetricsDto.
     * @summary Get key metrics for user\'s rooms
     * @param {string} period 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getKeyMetrics(period: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getKeyMetrics(period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the interaction analytics of the room as a RoomAnalyticsInteractionsDto.
     * @summary Get room interaction analytics
     * @param {string} roomID The ID of the room to get interaction analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomInteractionAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomInteractionAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the participation analytics of the room as a RoomAnalyticsParticipationDto.
     * @summary Get room participation analytics
     * @param {string} roomID The ID of the room to get participation analytics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomAnalyticsApi
     */
    public getRoomParticipationAnalytics(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomAnalyticsApiFp(this.configuration).getRoomParticipationAnalytics(roomID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomManagementApi - axios parameter creator
 * @export
 */
export const RoomManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permanently bans a user from the room.
         * @summary Perma ban someone from a room
         * @param {string} roomID The ID of the room to ban the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be banned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser: async (roomID: string, userActionDto: UserActionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('banUser', 'roomID', roomID)
            // verify required parameter 'userActionDto' is not null or undefined
            assertParamExists('banUser', 'userActionDto', userActionDto)
            const localVarPath = `/rooms/{roomID}/banned`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of UserDto representing the banned users in the room.
         * @summary Get list of banned users
         * @param {string} roomID The ID of the room to get the banned users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBannedUsers: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getBannedUsers', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/banned`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of UserDto representing users who were been kicked from the room.
         * @summary Get list of kicked users
         * @param {string} roomID The ID of the room to get the kicked users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKickedUsers: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getKickedUsers', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/kicked`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kicks a user out of the room.
         * @summary Kick someone out of a room
         * @param {string} roomID The ID of the room to kick the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be kicked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickUser: async (roomID: string, userActionDto: UserActionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('kickUser', 'roomID', roomID)
            // verify required parameter 'userActionDto' is not null or undefined
            assertParamExists('kickUser', 'userActionDto', userActionDto)
            const localVarPath = `/rooms/{roomID}/kicked`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undoes the ban of a participant in the room.
         * @summary Undo participant ban
         * @param {string} roomID The ID of the room to undo the ban in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the ban for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoBan: async (roomID: string, userActionDto: UserActionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('undoBan', 'roomID', roomID)
            // verify required parameter 'userActionDto' is not null or undefined
            assertParamExists('undoBan', 'userActionDto', userActionDto)
            const localVarPath = `/rooms/{roomID}/banned`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undoes the kick of a participant in the room.
         * @summary Undo participant kick
         * @param {string} roomID The ID of the room to undo the kick in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the kick for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoKick: async (roomID: string, userActionDto: UserActionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('undoKick', 'roomID', roomID)
            // verify required parameter 'userActionDto' is not null or undefined
            assertParamExists('undoKick', 'userActionDto', userActionDto)
            const localVarPath = `/rooms/{roomID}/kicked`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomManagementApi - functional programming interface
 * @export
 */
export const RoomManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Permanently bans a user from the room.
         * @summary Perma ban someone from a room
         * @param {string} roomID The ID of the room to ban the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be banned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banUser(roomID, userActionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.banUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an array of UserDto representing the banned users in the room.
         * @summary Get list of banned users
         * @param {string} roomID The ID of the room to get the banned users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBannedUsers(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBannedUsers(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.getBannedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an array of UserDto representing users who were been kicked from the room.
         * @summary Get list of kicked users
         * @param {string} roomID The ID of the room to get the kicked users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKickedUsers(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKickedUsers(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.getKickedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kicks a user out of the room.
         * @summary Kick someone out of a room
         * @param {string} roomID The ID of the room to kick the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be kicked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kickUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kickUser(roomID, userActionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.kickUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Undoes the ban of a participant in the room.
         * @summary Undo participant ban
         * @param {string} roomID The ID of the room to undo the ban in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the ban for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoBan(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undoBan(roomID, userActionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.undoBan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Undoes the kick of a participant in the room.
         * @summary Undo participant kick
         * @param {string} roomID The ID of the room to undo the kick in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the kick for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoKick(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undoKick(roomID, userActionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomManagementApi.undoKick']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomManagementApi - factory interface
 * @export
 */
export const RoomManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomManagementApiFp(configuration)
    return {
        /**
         * Permanently bans a user from the room.
         * @summary Perma ban someone from a room
         * @param {string} roomID The ID of the room to ban the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be banned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.banUser(roomID, userActionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of UserDto representing the banned users in the room.
         * @summary Get list of banned users
         * @param {string} roomID The ID of the room to get the banned users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBannedUsers(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getBannedUsers(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of UserDto representing users who were been kicked from the room.
         * @summary Get list of kicked users
         * @param {string} roomID The ID of the room to get the kicked users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKickedUsers(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getKickedUsers(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Kicks a user out of the room.
         * @summary Kick someone out of a room
         * @param {string} roomID The ID of the room to kick the user from.
         * @param {UserActionDto} userActionDto The user ID of the user to be kicked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.kickUser(roomID, userActionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Undoes the ban of a participant in the room.
         * @summary Undo participant ban
         * @param {string} roomID The ID of the room to undo the ban in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the ban for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoBan(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.undoBan(roomID, userActionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Undoes the kick of a participant in the room.
         * @summary Undo participant kick
         * @param {string} roomID The ID of the room to undo the kick in.
         * @param {UserActionDto} userActionDto The user ID of the user to undo the kick for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoKick(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.undoKick(roomID, userActionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomManagementApi - object-oriented interface
 * @export
 * @class RoomManagementApi
 * @extends {BaseAPI}
 */
export class RoomManagementApi extends BaseAPI {
    /**
     * Permanently bans a user from the room.
     * @summary Perma ban someone from a room
     * @param {string} roomID The ID of the room to ban the user from.
     * @param {UserActionDto} userActionDto The user ID of the user to be banned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public banUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).banUser(roomID, userActionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of UserDto representing the banned users in the room.
     * @summary Get list of banned users
     * @param {string} roomID The ID of the room to get the banned users for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public getBannedUsers(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).getBannedUsers(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of UserDto representing users who were been kicked from the room.
     * @summary Get list of kicked users
     * @param {string} roomID The ID of the room to get the kicked users for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public getKickedUsers(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).getKickedUsers(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kicks a user out of the room.
     * @summary Kick someone out of a room
     * @param {string} roomID The ID of the room to kick the user from.
     * @param {UserActionDto} userActionDto The user ID of the user to be kicked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public kickUser(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).kickUser(roomID, userActionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Undoes the ban of a participant in the room.
     * @summary Undo participant ban
     * @param {string} roomID The ID of the room to undo the ban in.
     * @param {UserActionDto} userActionDto The user ID of the user to undo the ban for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public undoBan(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).undoBan(roomID, userActionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Undoes the kick of a participant in the room.
     * @summary Undo participant kick
     * @param {string} roomID The ID of the room to undo the kick in.
     * @param {UserActionDto} userActionDto The user ID of the user to undo the kick for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomManagementApi
     */
    public undoKick(roomID: string, userActionDto: UserActionDto, options?: RawAxiosRequestConfig) {
        return RoomManagementApiFp(this.configuration).undoKick(roomID, userActionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('bookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/bookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Evaluate if a room can be split
         * @param {string} roomID The ID of the room to evaluate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkRoomSplit: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('checkRoomSplit', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/split`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('deleteRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the scheduled room as a .ics file.
         * @summary Get scheduled room
         * @param {string} roomID The ID of the room to get the schedule for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarFile: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getCalendarFile', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/schedule`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSong: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getCurrentSong', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs/current`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveChatHistory: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getLiveChatHistory', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/chat/history`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomInfo', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the queue of the room as an array of RoomSongDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueue: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomQueue', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/songs`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomUsers: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('getRoomUsers', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/users`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the rooms as an array of RoomDto.
         * @summary Get multiple rooms
         * @param {Array<string>} q An array of room IDs to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRooms: async (q: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('getRooms', 'q', q)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('joinRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/join`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('leaveRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/leave`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoomInfo: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('putRoomInfo', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('putRoomInfo', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save room as a playlist
         * @param {string} roomID The ID of the room to save as a playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('saveRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/save`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shares the room with the given users.
         * @summary Share a room
         * @param {string} roomID The ID of the room to share.
         * @param {Array<string>} requestBody The user IDs of the user to share the room with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRoom: async (roomID: string, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('shareRoom', 'roomID', roomID)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('shareRoom', 'requestBody', requestBody)
            const localVarPath = `/rooms/{roomID}/share`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a RoomDto with info about its split children
         * @param {string} roomID The ID of the room to get the split children for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('splitRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/split`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('unbookmarkRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/unbookmark`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsave room as a playlist
         * @param {string} roomID The ID of the room to remove from the user\&#39;s playlists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsaveRoom: async (roomID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('unsaveRoom', 'roomID', roomID)
            const localVarPath = `/rooms/{roomID}/unsave`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomInfo: async (roomID: string, updateRoomDto: UpdateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomID' is not null or undefined
            assertParamExists('updateRoomInfo', 'roomID', roomID)
            // verify required parameter 'updateRoomDto' is not null or undefined
            assertParamExists('updateRoomInfo', 'updateRoomDto', updateRoomDto)
            const localVarPath = `/rooms/{roomID}`
                .replace(`{${"roomID"}}`, encodeURIComponent(String(roomID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoomByUserId: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerGetCurrentRoomByUserId', 'username', username)
            const localVarPath = `/users/{username}/rooms/current`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.bookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Evaluate if a room can be split
         * @param {string} roomID The ID of the room to evaluate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkRoomSplit(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkRoomSplit(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.checkRoomSplit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the scheduled room as a .ics file.
         * @summary Get scheduled room
         * @param {string} roomID The ID of the room to get the schedule for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendarFile(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendarFile(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getCalendarFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentSong(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomSongDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentSong(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getCurrentSong']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveChatMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveChatHistory(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getLiveChatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getNewRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomInfo(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomInfo(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the queue of the room as an array of RoomSongDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomQueue(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomSongDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomQueue(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomUsers(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomUsers(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRoomUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the rooms as an array of RoomDto.
         * @summary Get multiple rooms
         * @param {Array<string>} q An array of room IDs to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRooms(q: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRooms(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.getRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.joinRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.leaveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putRoomInfo(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.putRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Save room as a playlist
         * @param {string} roomID The ID of the room to save as a playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.saveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Shares the room with the given users.
         * @summary Share a room
         * @param {string} roomID The ID of the room to share.
         * @param {Array<string>} requestBody The user IDs of the user to share the room with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareRoom(roomID: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareRoom(roomID, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.shareRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a RoomDto with info about its split children
         * @param {string} roomID The ID of the room to get the split children for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.splitRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbookmarkRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.unbookmarkRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unsave room as a playlist
         * @param {string} roomID The ID of the room to remove from the user\&#39;s playlists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsaveRoom(roomID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsaveRoom(roomID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.unsaveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoomInfo(roomID, updateRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.updateRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetCurrentRoomByUserId(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.usersControllerGetCurrentRoomByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * Adds the room to the user\'s bookmarks.
         * @summary Bookmark a room
         * @param {string} roomID The ID of the room to bookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Evaluate if a room can be split
         * @param {string} roomID The ID of the room to evaluate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkRoomSplit(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkRoomSplit(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomID The ID of the room to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the scheduled room as a .ics file.
         * @summary Get scheduled room
         * @param {string} roomID The ID of the room to get the schedule for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarFile(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getCalendarFile(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the song currently playing in the room.
         * @summary Get the current song of a room
         * @param {string} roomID The ID of the room to get the current song for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSong(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomSongDto> {
            return localVarFp.getCurrentSong(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the chat history of the room as an array of LiveChatMessageDto.
         * @summary Get the chat history of a room
         * @param {string} roomID The ID of the room to get the chat history for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveChatMessageDto>> {
            return localVarFp.getLiveChatHistory(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the new public rooms as an array of RoomDto.
         * @summary Get newly created public rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getNewRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the room info as a RoomDto.
         * @summary Get room info
         * @param {string} roomID The ID of the room to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomInfo(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.getRoomInfo(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the queue of the room as an array of RoomSongDto.
         * @summary Get the queue of a room
         * @param {string} roomID The ID of the room to get the queue for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomQueue(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomSongDto>> {
            return localVarFp.getRoomQueue(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the users in the room as an array of UserDto.
         * @summary Get users in a room
         * @param {string} roomID The ID of the room to get users for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomUsers(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getRoomUsers(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the rooms as an array of RoomDto.
         * @summary Get multiple rooms
         * @param {Array<string>} q An array of room IDs to get info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRooms(q: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRooms(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the current user as a participant to the room.
         * @summary Join a room
         * @param {string} roomID The ID of the room to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.joinRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the current user as a participant to the room.
         * @summary Leave a room
         * @param {string} roomID The ID of the room to leave.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.putRoomInfo(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save room as a playlist
         * @param {string} roomID The ID of the room to save as a playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.saveRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Shares the room with the given users.
         * @summary Share a room
         * @param {string} roomID The ID of the room to share.
         * @param {Array<string>} requestBody The user IDs of the user to share the room with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRoom(roomID: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.shareRoom(roomID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a RoomDto with info about its split children
         * @param {string} roomID The ID of the room to get the split children for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.splitRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the room from the user\'s bookmarks.
         * @summary Unbookmark a room
         * @param {string} roomID The ID of the room to unbookmark.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unbookmarkRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsave room as a playlist
         * @param {string} roomID The ID of the room to remove from the user\&#39;s playlists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsaveRoom(roomID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unsaveRoom(roomID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update room info
         * @param {string} roomID The ID of the room to update.
         * @param {UpdateRoomDto} updateRoomDto The updated room info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.updateRoomInfo(roomID, updateRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerGetCurrentRoomByUserId(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * Adds the room to the user\'s bookmarks.
     * @summary Bookmark a room
     * @param {string} roomID The ID of the room to bookmark.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public bookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).bookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Evaluate if a room can be split
     * @param {string} roomID The ID of the room to evaluate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public checkRoomSplit(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).checkRoomSplit(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room
     * @param {string} roomID The ID of the room to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public deleteRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).deleteRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the scheduled room as a .ics file.
     * @summary Get scheduled room
     * @param {string} roomID The ID of the room to get the schedule for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getCalendarFile(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getCalendarFile(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the song currently playing in the room.
     * @summary Get the current song of a room
     * @param {string} roomID The ID of the room to get the current song for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getCurrentSong(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getCurrentSong(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the chat history of the room as an array of LiveChatMessageDto.
     * @summary Get the chat history of a room
     * @param {string} roomID The ID of the room to get the chat history for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getLiveChatHistory(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getLiveChatHistory(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the new public rooms as an array of RoomDto.
     * @summary Get newly created public rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getNewRooms(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getNewRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the room info as a RoomDto.
     * @summary Get room info
     * @param {string} roomID The ID of the room to get info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomInfo(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomInfo(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the queue of the room as an array of RoomSongDto.
     * @summary Get the queue of a room
     * @param {string} roomID The ID of the room to get the queue for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomQueue(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomQueue(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the users in the room as an array of UserDto.
     * @summary Get users in a room
     * @param {string} roomID The ID of the room to get users for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomUsers(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomUsers(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the rooms as an array of RoomDto.
     * @summary Get multiple rooms
     * @param {Array<string>} q An array of room IDs to get info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRooms(q: Array<string>, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRooms(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the current user as a participant to the room.
     * @summary Join a room
     * @param {string} roomID The ID of the room to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public joinRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).joinRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the current user as a participant to the room.
     * @summary Leave a room
     * @param {string} roomID The ID of the room to leave.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public leaveRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).leaveRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room info
     * @param {string} roomID The ID of the room to update.
     * @param {UpdateRoomDto} updateRoomDto The updated room info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public putRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).putRoomInfo(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save room as a playlist
     * @param {string} roomID The ID of the room to save as a playlist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public saveRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).saveRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shares the room with the given users.
     * @summary Share a room
     * @param {string} roomID The ID of the room to share.
     * @param {Array<string>} requestBody The user IDs of the user to share the room with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public shareRoom(roomID: string, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).shareRoom(roomID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a RoomDto with info about its split children
     * @param {string} roomID The ID of the room to get the split children for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public splitRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).splitRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the room from the user\'s bookmarks.
     * @summary Unbookmark a room
     * @param {string} roomID The ID of the room to unbookmark.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public unbookmarkRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).unbookmarkRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsave room as a playlist
     * @param {string} roomID The ID of the room to remove from the user\&#39;s playlists.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public unsaveRoom(roomID: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).unsaveRoom(roomID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update room info
     * @param {string} roomID The ID of the room to update.
     * @param {UpdateRoomDto} updateRoomDto The updated room info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public updateRoomInfo(roomID: string, updateRoomDto: UpdateRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).updateRoomInfo(roomID, updateRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s current room based on username
     * @param {string} username The username of user\&#39;s current room to search for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).usersControllerGetCurrentRoomByUserId(username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchRooms: async (q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('advancedSearchRooms', 'q', q)
            const localVarPath = `/search/rooms/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (participantCount !== undefined) {
                localVarQueryParameter['participant_count'] = participantCount;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (isTemp !== undefined) {
                localVarQueryParameter['is_temp'] = isTemp;
            }

            if (isPriv !== undefined) {
                localVarQueryParameter['is_priv'] = isPriv;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['is_scheduled'] = isScheduled;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['explicit'] = explicit;
            }

            if (nsfw !== undefined) {
                localVarQueryParameter['nsfw'] = nsfw;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchUsers: async (q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('advancedSearchUsers', 'q', q)
            const localVarPath = `/search/users/advanced`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creatorUsername !== undefined) {
                localVarQueryParameter['creator_username'] = creatorUsername;
            }

            if (creatorName !== undefined) {
                localVarQueryParameter['creator_name'] = creatorName;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            if (followers !== undefined) {
                localVarQueryParameter['followers'] = followers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSearchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRooms: async (q: string, creator?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchRooms', 'q', q)
            const localVarPath = `/search/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/rooms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recommended room search terms.
         * @summary Get recommended room search terms.
         * @param {string} q A room name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsSuggestion: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchRoomsSuggestion', 'q', q)
            const localVarPath = `/search/rooms/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchUsers', 'q', q)
            const localVarPath = `/search/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/users/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recommended user search terms.
         * @summary Get recommended user search terms.
         * @param {string} q A user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSuggestion: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchUsersSuggestion', 'q', q)
            const localVarPath = `/search/users/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.advancedSearchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.advancedSearchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearSearchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearSearchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearSearchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.clearUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CombinedSearchHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRooms(q, creator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRoomsHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRoomsHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchRoomsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recommended room search terms.
         * @summary Get recommended room search terms.
         * @param {string} q A room name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRoomsSuggestion(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRoomsSuggestion(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchRoomsSuggestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recommended user search terms.
         * @summary Get recommended user search terms.
         * @param {string} q A user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersSuggestion(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersSuggestion(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUsersSuggestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Advanced search for rooms by various parameters.
         * @summary Advanced search for rooms
         * @param {string} q A room name
         * @param {string} [creatorUsername] A room creator\&#39;s username
         * @param {string} [creatorName] A room creator\&#39;s profile name
         * @param {number} [participantCount] Minimum number of participants
         * @param {string} [description] A string to find in the room description
         * @param {boolean} [isTemp] Is the room temporary?
         * @param {boolean} [isPriv] Is the room private?
         * @param {boolean} [isScheduled] Is the room scheduled?
         * @param {string} [startDate] Only if scheduled, the start date
         * @param {string} [endDate] Only if scheduled, the end date
         * @param {string} [lang] The room language (as a ISO 639-1 code)
         * @param {boolean} [explicit] Is the room explicit?
         * @param {boolean} [nsfw] Is the room NSFW?
         * @param {string} [tags] A comma separated list of tags to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Advanced search for users by various parameters.
         * @summary Advanced search for users
         * @param {string} q A username or profile name
         * @param {string} [creatorUsername] A user\&#39;s username
         * @param {string} [creatorName] A user\&#39;s profile name
         * @param {number} [following] Minimum number of following
         * @param {number} [followers] Minimum number of followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear room search history for the user.
         * @summary Clear room search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Clear search history for the user.
         * @summary Clear search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSearchHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearSearchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Clear user search history for the user.
         * @summary Clear user search history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearUsersHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for rooms and users by room name, creator name or username.
         * @summary Search for rooms and users
         * @param {string} q A room name / username
         * @param {string} [creator] A room creator\&#39;s profile name or username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<CombinedSearchResults> {
            return localVarFp.search(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get search history (including objects discovered from search)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<CombinedSearchHistory>> {
            return localVarFp.searchHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for rooms by room name or creator name / username.
         * @summary Search for rooms
         * @param {string} q A room name
         * @param {string} [creator] A room creator\&#39;s profile name / username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.searchRooms(q, creator, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recently searched rooms by the user.
         * @summary Get recently searched rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchRoomsHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recommended room search terms.
         * @summary Get recommended room search terms.
         * @param {string} q A room name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRoomsSuggestion(q: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchRoomsSuggestion(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for users by username or profile name.
         * @summary Search for users
         * @param {string} q A username or profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(q: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.searchUsers(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recently searched users by the user.
         * @summary Get recently searched users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchUsersHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Get recommended user search terms.
         * @summary Get recommended user search terms.
         * @param {string} q A user name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersSuggestion(q: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHistoryDto>> {
            return localVarFp.searchUsersSuggestion(q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Advanced search for rooms by various parameters.
     * @summary Advanced search for rooms
     * @param {string} q A room name
     * @param {string} [creatorUsername] A room creator\&#39;s username
     * @param {string} [creatorName] A room creator\&#39;s profile name
     * @param {number} [participantCount] Minimum number of participants
     * @param {string} [description] A string to find in the room description
     * @param {boolean} [isTemp] Is the room temporary?
     * @param {boolean} [isPriv] Is the room private?
     * @param {boolean} [isScheduled] Is the room scheduled?
     * @param {string} [startDate] Only if scheduled, the start date
     * @param {string} [endDate] Only if scheduled, the end date
     * @param {string} [lang] The room language (as a ISO 639-1 code)
     * @param {boolean} [explicit] Is the room explicit?
     * @param {boolean} [nsfw] Is the room NSFW?
     * @param {string} [tags] A comma separated list of tags to compare
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public advancedSearchRooms(q: string, creatorUsername?: string, creatorName?: string, participantCount?: number, description?: string, isTemp?: boolean, isPriv?: boolean, isScheduled?: boolean, startDate?: string, endDate?: string, lang?: string, explicit?: boolean, nsfw?: boolean, tags?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).advancedSearchRooms(q, creatorUsername, creatorName, participantCount, description, isTemp, isPriv, isScheduled, startDate, endDate, lang, explicit, nsfw, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Advanced search for users by various parameters.
     * @summary Advanced search for users
     * @param {string} q A username or profile name
     * @param {string} [creatorUsername] A user\&#39;s username
     * @param {string} [creatorName] A user\&#39;s profile name
     * @param {number} [following] Minimum number of following
     * @param {number} [followers] Minimum number of followers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public advancedSearchUsers(q: string, creatorUsername?: string, creatorName?: string, following?: number, followers?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).advancedSearchUsers(q, creatorUsername, creatorName, following, followers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear room search history for the user.
     * @summary Clear room search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear search history for the user.
     * @summary Clear search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearSearchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearSearchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear user search history for the user.
     * @summary Clear user search history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public clearUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).clearUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for rooms and users by room name, creator name or username.
     * @summary Search for rooms and users
     * @param {string} q A room name / username
     * @param {string} [creator] A room creator\&#39;s profile name or username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get search history (including objects discovered from search)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for rooms by room name or creator name / username.
     * @summary Search for rooms
     * @param {string} q A room name
     * @param {string} [creator] A room creator\&#39;s profile name / username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchRooms(q: string, creator?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchRooms(q, creator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recently searched rooms by the user.
     * @summary Get recently searched rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchRoomsHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchRoomsHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recommended room search terms.
     * @summary Get recommended room search terms.
     * @param {string} q A room name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchRoomsSuggestion(q: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchRoomsSuggestion(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for users by username or profile name.
     * @summary Search for users
     * @param {string} q A username or profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsers(q: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsers(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recently searched users by the user.
     * @summary Get recently searched users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsersHistory(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsersHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recommended user search terms.
     * @summary Get recommended user search terms.
     * @param {string} q A user name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsersSuggestion(q: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUsersSuggestion(q, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('acceptFriendRequest', 'username', username)
            const localVarPath = `/users/{username}/accept`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        befriendUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('befriendUser', 'username', username)
            const localVarPath = `/users/{username}/befriend`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Block the user with the given username.
         * @summary Block a given user
         * @param {string} username The username of the user to block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('blockUser', 'username', username)
            const localVarPath = `/users/{username}/block`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequest: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('cancelFriendRequest', 'username', username)
            const localVarPath = `/users/{username}/cancel`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequest_1: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('cancelFriendRequest_1', 'username', username)
            const localVarPath = `/users/{username}/cancel`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (createRoomDto: CreateRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDto' is not null or undefined
            assertParamExists('createRoom', 'createRoomDto', createRoomDto)
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('followUser', 'username', username)
            const localVarPath = `/users/{username}/follow`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the users that the authenticated user has blocked.
         * @summary Get blocked users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocked: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/blocked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarksByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getBookmarksByUsername', 'username', username)
            const localVarPath = `/users/{username}/bookmarks`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRoom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/dms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the direct messages between the two users.
         * @summary Get the authorized user\'s direct messages with the given user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMsByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getDMsByUsername', 'username', username)
            const localVarPath = `/users/{username}/dms`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the listening stats of the authenticated user, including total time listened, and average listening time per day, most played songs, genres, and artists.
         * @summary Get a user\'s listening stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListeningStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequests_2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getProfileByUsername', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRoomsByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getRecentRoomsByUsername', 'username', username)
            const localVarPath = `/users/{username}/rooms/recent`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the given username is already taken.
         * @summary Check if a username is taken
         * @param {string} username The username of the user to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUsernameTaken: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('isUsernameTaken', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('patchProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProfile: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('putProfile', 'updateUserDto', updateUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequest: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('rejectFriendRequest', 'username', username)
            const localVarPath = `/users/{username}/reject`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report the user with the given username.
         * @summary Report a given user
         * @param {string} username The username of the user to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('reportUser', 'username', username)
            const localVarPath = `/users/{username}/report`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unblock the user with the given username.
         * @summary Unblock a given user
         * @param {string} username The username of the user to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('unblockUser', 'username', username)
            const localVarPath = `/users/{username}/unblock`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('unfollowUser', 'username', username)
            const localVarPath = `/users/{username}/unfollow`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriendUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('unfriendUser', 'username', username)
            const localVarPath = `/users/{username}/unfriend`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoomByUserId: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('usersControllerGetCurrentRoomByUserId', 'username', username)
            const localVarPath = `/users/{username}/rooms/current`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPotentialFriends: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/potential`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPotentialFriends_3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/friends/potential`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedUsers_4: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/foryou`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequest(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequest(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.acceptFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async befriendUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.befriendUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.befriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Block the user with the given username.
         * @summary Block a given user
         * @param {string} username The username of the user to block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.blockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelFriendRequest(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelFriendRequest(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.cancelFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelFriendRequest_1(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelFriendRequest_1(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.cancelFriendRequest_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoom(createRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.followUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the users that the authenticated user has blocked.
         * @summary Get blocked users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocked(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocked(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getBlocked']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarksByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarksByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getBookmarksByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentRoom(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentRoom(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DirectMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getDMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the direct messages between the two users.
         * @summary Get the authorized user\'s direct messages with the given user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDMsByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DirectMessageDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDMsByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getDMsByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFriendRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFriendRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFriendRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the listening stats of the authenticated user, including total time listened, and average listening time per day, most played songs, genres, and artists.
         * @summary Get a user\'s listening stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListeningStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListeningStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListeningStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getListeningStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getPendingRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingRequests_2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingRequests_2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getPendingRequests_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getRecentRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentRoomsByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentRoomsByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getRecentRoomsByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getRecommendedRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if the given username is already taken.
         * @summary Check if a username is taken
         * @param {string} username The username of the user to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUsernameTaken(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isUsernameTaken(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.isUsernameTaken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.patchProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProfile(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.putProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFriendRequest(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFriendRequest(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.rejectFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Report the user with the given username.
         * @summary Report a given user
         * @param {string} username The username of the user to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.reportUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unblock the user with the given username.
         * @summary Unblock a given user
         * @param {string} username The username of the user to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unblockUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unblockUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unblockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unfollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfriendUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfriendUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unfriendUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetCurrentRoomByUserId(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetCurrentRoomByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetPotentialFriends(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetPotentialFriends(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetPotentialFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetPotentialFriends_3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetPotentialFriends_3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetPotentialFriends_3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecommendedUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecommendedUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecommendedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetRecommendedUsers_4(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetRecommendedUsers_4(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetRecommendedUsers_4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Accept a friend request from the user with the given username.
         * @summary Accept a friend request from the given user
         * @param {string} username Our new friend. The username of the user to accept a friend request from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptFriendRequest(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a friend request to the user with the given username.
         * @summary Send a friend request to the given user
         * @param {string} username The username of the user to send a friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        befriendUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.befriendUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Block the user with the given username.
         * @summary Block a given user
         * @param {string} username The username of the user to block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.blockUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequest(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelFriendRequest(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a friend request to the given user
         * @param {string} username The username of the user to cancel the friend request to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequest_1(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelFriendRequest_1(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new room with the given information.
         * @summary Create a new room
         * @param {CreateRoomDto} createRoomDto The room to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.createRoom(createRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow the user with the given username.
         * @summary Follow the given user
         * @param {string} username The username of the user to follow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.followUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the users that the authenticated user has blocked.
         * @summary Get blocked users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocked(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getBlocked(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getBookmarks(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the rooms that the user has bookmarked.
         * @summary Get the authorized user\'s bookmarks
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarksByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getBookmarksByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the room that the user is currently in.
         * @summary Get a user\'s current room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentRoom(options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.getCurrentRoom(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the last DMs either sent to or received from another user
         * @summary Get the last DMs sent to or received from another user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMs(options?: RawAxiosRequestConfig): AxiosPromise<Array<DirectMessageDto>> {
            return localVarFp.getDMs(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the direct messages between the two users.
         * @summary Get the authorized user\'s direct messages with the given user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDMsByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DirectMessageDto>> {
            return localVarFp.getDMsByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the users that follow the authenticated user.
         * @summary Get a user\'s followers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFollowers(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the users that the authenticated user follows.
         * @summary Get a user\'s following
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowing(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFollowing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendRequests(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getFriendRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the listening stats of the authenticated user, including total time listened, and average listening time per day, most played songs, genres, and artists.
         * @summary Get a user\'s listening stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListeningStats(options?: RawAxiosRequestConfig): AxiosPromise<UserListeningStatsDto> {
            return localVarFp.getListeningStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequests(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getPendingRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s sent friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequests_2(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getPendingRequests_2(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile info of the currently authenticated user.
         * @summary Get current user\'s profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the profile info of the user with the given username.
         * @summary Get user profile info by username
         * @param {string} username The username of the user to fetch profile info for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getProfileByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRecentRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s most recently visited rooms.
         * @summary Get a user\'s recent rooms
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentRoomsByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRecentRoomsByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the rooms that are recommended for the user.
         * @summary Get a user\'s recommended rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getRecommendedRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.getUserFriends(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the rooms that the user created.
         * @summary Get the user\'s rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRooms(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDto>> {
            return localVarFp.getUserRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the given username is already taken.
         * @summary Check if a username is taken
         * @param {string} username The username of the user to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUsernameTaken(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.isUsernameTaken(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.patchProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the profile info of the currently authenticated user.
         * @summary Update user\'s profile info
         * @param {UpdateUserDto} updateUserDto The updated user profile info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.putProfile(updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject a friend request from the user with the given username.
         * @summary Reject a friend request from the given user
         * @param {string} username The username of the user whose friend request we are rejecting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequest(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejectFriendRequest(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Report the user with the given username.
         * @summary Report a given user
         * @param {string} username The username of the user to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reportUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Unblock the user with the given username.
         * @summary Unblock a given user
         * @param {string} username The username of the user to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unblockUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow the user with the given username.
         * @summary Unfollow the given user
         * @param {string} username The username of the user to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unfollowUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * End friendship with the user with the given username.
         * @summary End friendship with the given user
         * @param {string} username The username of the user to end friendship with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriendUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unfriendUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s current room based on username
         * @param {string} username The username of user\&#39;s current room to search for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDto> {
            return localVarFp.usersControllerGetCurrentRoomByUserId(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPotentialFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetPotentialFriends(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get potential friends for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetPotentialFriends_3(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetPotentialFriends_3(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetRecommendedUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recommended users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetRecommendedUsers_4(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersControllerGetRecommendedUsers_4(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Accept a friend request from the user with the given username.
     * @summary Accept a friend request from the given user
     * @param {string} username Our new friend. The username of the user to accept a friend request from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptFriendRequest(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptFriendRequest(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a friend request to the user with the given username.
     * @summary Send a friend request to the given user
     * @param {string} username The username of the user to send a friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public befriendUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).befriendUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Block the user with the given username.
     * @summary Block a given user
     * @param {string} username The username of the user to block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public blockUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).blockUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a friend request to the given user
     * @param {string} username The username of the user to cancel the friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public cancelFriendRequest(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).cancelFriendRequest(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a friend request to the given user
     * @param {string} username The username of the user to cancel the friend request to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public cancelFriendRequest_1(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).cancelFriendRequest_1(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new room with the given information.
     * @summary Create a new room
     * @param {CreateRoomDto} createRoomDto The room to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createRoom(createRoomDto: CreateRoomDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createRoom(createRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Follow the user with the given username.
     * @summary Follow the given user
     * @param {string} username The username of the user to follow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public followUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).followUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the users that the authenticated user has blocked.
     * @summary Get blocked users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBlocked(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getBlocked(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the rooms that the user has bookmarked.
     * @summary Get the authorized user\'s bookmarks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBookmarks(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getBookmarks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the rooms that the user has bookmarked.
     * @summary Get the authorized user\'s bookmarks
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getBookmarksByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getBookmarksByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the room that the user is currently in.
     * @summary Get a user\'s current room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentRoom(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentRoom(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the last DMs either sent to or received from another user
     * @summary Get the last DMs sent to or received from another user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDMs(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getDMs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the direct messages between the two users.
     * @summary Get the authorized user\'s direct messages with the given user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDMsByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getDMsByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the users that follow the authenticated user.
     * @summary Get a user\'s followers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFollowers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the users that the authenticated user follows.
     * @summary Get a user\'s following
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFollowing(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFriendRequests(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFriendRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the listening stats of the authenticated user, including total time listened, and average listening time per day, most played songs, genres, and artists.
     * @summary Get a user\'s listening stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getListeningStats(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getListeningStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s sent friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPendingRequests(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPendingRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s sent friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPendingRequests_2(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPendingRequests_2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile info of the currently authenticated user.
     * @summary Get current user\'s profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfile(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the profile info of the user with the given username.
     * @summary Get user profile info by username
     * @param {string} username The username of the user to fetch profile info for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfileByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s most recently visited rooms.
     * @summary Get a user\'s recent rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getRecentRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRecentRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s most recently visited rooms.
     * @summary Get a user\'s recent rooms
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getRecentRoomsByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRecentRoomsByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the rooms that are recommended for the user.
     * @summary Get a user\'s recommended rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getRecommendedRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getRecommendedRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s friends
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFriends(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserFriends(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the rooms that the user created.
     * @summary Get the user\'s rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRooms(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the given username is already taken.
     * @summary Check if a username is taken
     * @param {string} username The username of the user to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public isUsernameTaken(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).isUsernameTaken(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the profile info of the currently authenticated user.
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto The updated user profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public patchProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).patchProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the profile info of the currently authenticated user.
     * @summary Update user\'s profile info
     * @param {UpdateUserDto} updateUserDto The updated user profile info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putProfile(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).putProfile(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject a friend request from the user with the given username.
     * @summary Reject a friend request from the given user
     * @param {string} username The username of the user whose friend request we are rejecting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public rejectFriendRequest(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).rejectFriendRequest(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report the user with the given username.
     * @summary Report a given user
     * @param {string} username The username of the user to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public reportUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).reportUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unblock the user with the given username.
     * @summary Unblock a given user
     * @param {string} username The username of the user to unblock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unblockUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unblockUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfollow the user with the given username.
     * @summary Unfollow the given user
     * @param {string} username The username of the user to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unfollowUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unfollowUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End friendship with the user with the given username.
     * @summary End friendship with the given user
     * @param {string} username The username of the user to end friendship with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unfriendUser(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unfriendUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s current room based on username
     * @param {string} username The username of user\&#39;s current room to search for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetCurrentRoomByUserId(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetCurrentRoomByUserId(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get potential friends for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetPotentialFriends(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetPotentialFriends(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get potential friends for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetPotentialFriends_3(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetPotentialFriends_3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recommended users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecommendedUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecommendedUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recommended users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetRecommendedUsers_4(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetRecommendedUsers_4(options).then((request) => request(this.axios, this.basePath));
    }
}



