# Nest
<p align="center">
<a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>
<p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>

<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
<a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
<a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>

## Installation
```bash
$ npm install
```

## Running the app
```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test
```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```


---

# Welcome to Backend
This is a NestJS project with LOTS of plugins to support good programming.

## Navigating the files

### Files
- **API_SCHEMA.md**  
  Contains the schema documentation for the project's API.

- **check-versions.js**  
  A script to enforce the correct & consistent version of NodeJS.
  
- **jest.setup.js**  
  Jest configuration and setup script for testing.

- **nest-cli.json**  
  Configuration file for the Nest CLI.

- **package.json**  
  Lists project dependencies, scripts, and metadata. (for Node & NPM)

- **README.md**  
  Overview and documentation of the project.

- **tsconfig.json**  
  TypeScript compiler options and configuration for the project.

- **package-lock.json**  
  Records the exact version of each installed package to ensure consistent installs.

- **tsconfig.build.json**  
  TypeScript configuration for the build process.

- **webpack-hmr.config.js**  
  Webpack configuration for Hot Module Replacement (HMR).

### Directories

- **archive**  
  Archived files & folders.
  
- **coverage**  
  Contains code coverage reports generated by Jest.

- **dist**  
  Compiled output files from the TypeScript source code.
  
- **documentation**  
  Auto-generated documentation for the project.
  
- **jest_mocking**  
  Contains mock files for Jest testing.

- **node_modules**  
  Dependency modules & addons installed by npm.

- **prisma**  
  Contains Prisma-related files, including schema and migration configurations.

- **src**  
  Source code of the application.

- **test**  
  Contains unit and integration tests for the application.
  
- **tools**  
  Extra tools & scripts for development.

- **uploads**  
  Directory for uploaded files.

## Source files
### Files

- **app.controller.spec.ts**  
  Unit tests for the `AppController` class.

- **app.service.ts**  
  Contains the business logic for the `AppService` class.

- **app.controller.ts**  
  The main controller handling incoming requests and returning responses.

- **app.module.ts**  
  Main application module that imports and configures other modules and providers.

- **main.ts**  
  The entry point of the NestJS application, bootstrapping the app.

### Directories

- **auth**  
  Handles authentication-related functionality, including login, registration, and token management.

- **bull-config**  
  Configuration files for Bull queue management.

- **bull-board**  
  Provides a UI for monitoring Bull queues.

- **chat**  
  Manages chat functionalities, including messaging and chat rooms.

- **common**  
  Contains shared utilities, guards, and pipes used throughout the application.

- **config**  
  Configuration files and settings for different environments.

- **modules**  
  Contains the core modules of the application, organizing related features and components.

- **s3**  
  Integrations and services related to Amazon S3 for file storage.

- **spotify**  
  Integration with the Spotify API for handling music-related features. (Excluding Spotify Auth)

- **tasks**  
  Scheduled tasks and background jobs for the application.

## How things work in NestJS
NestJS is built for an MVC architecture out of the box.
It merges the backend and API layers into 1 server-side app.

### Controllers
All endpoints / accessible paths to the application are defined in controllers.
Eg. `GET /user` and `POST /user/settings` could be in `UserController.ts`


### Services
Controllers are best left to handle how input and output data flows through the application. Thus, the complex logic expected from the endpoints & paths are best kept in services.

Business logic, such as checking if data is valid, managing complex operations on the data, database (and other external service) interactions, etc are stored in services.

Eg, `getUserInfo()` or `getUserRooms()` would be stored in `UserService.ts`

### Modules
Given that controllers and services can be closely related and can also make use of other services, dependencies for them are stored in modules.

Modules in NestJS are used to organize the application into cohesive blocks of related functionality. They encapsulate controllers, providers (services), and other configuration elements, ensuring modularity and maintainability of the codebase.

Eg, `UserModule.ts` would link `UserService` and `UserController` together as well as manage their imports (shared or otherwise), make `UserController`'s  endpoints to the rest of the application, allow for `UserService` to be able to be imported by other services/controllers, etc

#### Defining a Module
A module definition looks like this:
```typescript
@Module({
	imports: [PrismaModule],
	controllers: [UsersController],
	providers: [
		UsersService,
		PrismaService,
		DtoGenService,
		DbUtilsService,
		AuthService,
	],
	exports: [UsersService],
})
export class UsersModule {}
```

1. **Imports**
When a module uses another module's functionalities and dependencies, they should be imported. This establishes a hierarchical relationship where modules can depend on one another.

Anything that's external to the module must have its accompanying Module imported here.

2. **Controllers**
By default, all modules are linked to the main `AppModule` and thus, any controllers added to the `controllers` list of a module makes them accessible when the server app is running.

3. **Providers**
Any services created and used within the module should be added to the providers list as that they can be injected into controllers or other services for loose coupling.

This is for any services & providers defined internally / within the module. No external services (eg. `PrismaService`) should be placed here.

4. **Exports**
Any components (like services/providers) used within the module and that should be made available for use in other modules should be added to the exports array. This allows them to be included in another module's providers without being concerned about the service's module structure.

## Coding Standards
(TBA)


# Frontend

# TuneIn with Expo Router

This README provides detailed instructions for setting up Expo Router in your React Native project. It includes examples of why these libraries are used, their advantages, common commands, and links to their respective resources.

## Table of Contents
- [Folder Structure](#folder-structure)
- [Installation](#installation)
  - [Expo Router](#expo-router)
- [Usage Examples](#usage-examples)
  - [Expo Router Usage](#expo-router-usage)
- [Advantages](#advantages)
- [Common Commands](#common-commands)
- [Editor Configuration](#editor-configuration)
- [Resources](#resources)

## Folder Structure

Here's an overview of how the project folders are structured:

```
my-app/
│
├── app/
│   ├── components/
│   │   ├── AppCarousel.tsx
│   │   ├── FriendsGrid.tsx
│   │   ├── NavBar.tsx
│   │   ├── RoomCardWidget.tsx
│   │   ├── TopNavBar.tsx
│   │   └── ... (other reusable components)
│   │
│   ├── models/
│   │   ├── friend.ts
│   │   ├── Room.ts
│   │   └── ... (other TypeScript class definitions)
│   │
│   ├── screens/
│   │   ├── rooms/
│   │   │   ├── RoomPage.tsx
│   │   │   ├── CreateRoom.tsx
│   │   │   └── ... (other room-related screens)
│   │   │
│   │   ├── auth/
│   │   │   ├── LoginScreen.tsx
│   │   │   ├── Register.tsx
│   │   │   └── ... (other auth-related screens)
│   │   │
│   │   └── ... (other pages/screens)
│   │
│   ├── hooks/
│   │   └── ... (reusable hooks)
│   │
│   └── index.tsx
│   
├── my-app.d.ts
├── babel.config.js
├── package.json
```

- **app/components/**: Contains all reusable components.
- **app/models/**: Contains TypeScript class definitions to streamline data handling.
- **app/screens/**: Contains all the screens (pages) of the app.
- **app/screens/rooms/**: Contains room-related screens.
- **app/screens/auth/**: Contains authentication-related screens.
- **app/hooks/**: Contains reusable hooks.
- **app/index.tsx**: The entry point for the app.

## Installation

### Expo Router

Expo Router provides a file-based routing solution for Expo projects.

1. **Install Expo Router:**

    ```bash
    npx expo install expo-router
    ```

2. **Set up routing configuration:**

    Create a folder structure under your project root with the following files:

    - app
      - _layout.tsx
      - index.tsx

    **_layout.tsx:**

    ```tsx
    import { Stack } from 'expo-router';

    const Layout = () => {
      return <Stack />;
    };

    export default Layout;
    ```

    **index.tsx:**

    ```tsx
    import React from 'react';
    import { View, Text } from 'react-native';

    const Home = () => {
      return (
        <View>
          <Text>Welcome to the Home Page</Text>
        </View>
      );
    };

    export default Home;
    ```

3. **Update app.json:**

    Make sure to include the expo-router plugin:

    ```json
    {
      "expo": {
        "plugins": [
          [
            "expo-router",
            {
              "origin": "router"
            }
          ]
        ]
      }
    }
    ```

## Usage Examples

### Expo Router Usage

#### Using Link Component

The Link component is a convenient way to navigate between screens declaratively.

1. **Create a new screen component:**

    ```tsx
    // screens/Profile.tsx
    import React from 'react';
    import { View, Text } from 'react-native';

    const Profile = () => {
      return (
        <View>
          <Text>This is the Profile Page</Text>
        </View>
      );
    };

    export default Profile;
    ```

2. **Link to the new screen using Link component:**

    ```tsx
    // screens/Home.tsx
    import React from 'react';
    import { View, Text } from 'react-native';
    import { Link } from 'expo-router';

    const Home = () => {
      return (
        <View>
          <Text>Welcome to the Home Page</Text>
          <Link href="/screens/Profile">
            <Text style={{ color: 'blue' }}>Go to Profile</Text>
          </Link>
        </View>
      );
    };

    export default Home;
    ```

#### Using router.navigate

For more programmatic navigation, use the router.navigate method.

1. **Create a new screen component:**

    ```tsx
    // screens/Settings.tsx
    import React from 'react';
    import { View, Text } from 'react-native';

    const Settings = () => {
      return (
        <View>
          <Text>This is the Settings Page</Text>
        </View>
      );
    };

    export default Settings;
    ```

2. **Navigate to the new screen using router.navigate:**

    ```tsx
    // screens/Home.tsx
    import React from 'react';
    import { View, Text, Button } from 'react-native';
    import { useRouter } from 'expo-router';

    const Home = () => {
      const router = useRouter();

      return (
        <View>
          <Text>Welcome to the Home Page</Text>
          <Button title="Go to Settings" onPress={() => router.navigate('/screens/Settings')} />
        </View>
      );
    };

    export default Home;
    ```

## Advantages

### Expo Router

- **Simplicity:** File-based routing makes navigation structure clear and easy to manage.
- **Productivity:** Quickly set up and navigate between screens without complex configuration.
- **Integration:** Seamlessly integrates with Expo's existing ecosystem and tools.

## Common Commands

### Expo Router Commands

- **Run the project:**

    ```bash
    npx expo start
    ```

- **Build the project:**

    ```bash
    npx expo build
    ```

## Editor Configuration

To ensure code quality and consistency, follow these practices:

- **ESLint and Prettier:** Use Prettier ESLint for linting and formatting.

    ```bash
    npx eslint --fix 'app/**/*.tsx'
    ```

- **Naming Conventions:** Use consistent naming conventions for files and folders.
  - Use `PascalCase` for component and screen files (e.g., `RoomPage.tsx`, `LoginScreen.tsx`).
  - Use `camelCase` for hooks and utility functions (e.g., `useFetchData.ts`, `formatDate.ts`).

- **Styling:** Use `createStyleSheet` for styling instead of Tailwind CSS. Create a central file for theme colors and other styling elements.

    ```tsx
    // styles/colors.ts
    export const colors = {
      primary: '#3498db',
      secondary: '#2ecc71',
      // Add other colors here
    };

    // styles/themes.ts
    import { StyleSheet } from 'react-native';
    import { colors } from './colors';

    export const commonStyles = StyleSheet.create({
      container: {
        flex: 1,
        padding: 20,
        backgroundColor: colors.primary,
      },
      // Add other styles here
    });
    ```

Sure, here's the continuation and completion of the README:

## Resources

### Expo Router

- [Expo Router Documentation](https://expo.github.io/router/docs/)

### General Resources

- [React Native Documentation](https://reactnative.dev/docs/getting-started)
- [Expo Documentation](https://docs.expo.dev/)
- [TypeScript Documentation](https://www.typescriptlang.org/docs/)

## Best Practices

To ensure the maintainability and scalability of your project, follow these best practices:

### Component Structure

- **Separate Concerns:** Split different components of a page into separate files. For example, in a room page, separate the chat functionality from the room page code.
- **Avoid Coupling:** Avoid tightly coupling components together. Abstract functionality to promote reusability.

### Testing

- **Component Tests:** Ensure all components have passing tests.
- **Automated Testing:** Use libraries like Jest and React Testing Library for automated testing.

### Code Quality

- **Linting:** Run linting before committing any code changes to ensure code quality.

    ```bash
    npx eslint --fix 'app/**/*.tsx'
    ```

- **Formatting:** Use Prettier for consistent code formatting.

### Styling

- **Centralized Styling:** Use a centralized file for colors and other styling elements. This promotes consistency and easy maintenance.

    ```tsx
    // styles/colors.ts
    export const colors = {
      primary: '#08BDBD',
      secondary: '#8B8FA8',
      // Add other colors here
    };

    // styles/fonts.ts
    export const fonts = {
      primary: 'Poppins_400Regular',
      // Add other font styles here
    };
  
    // styles/themes.ts
    import { StyleSheet } from 'react-native';
    import { colors } from './colors';
    import { fonts } from './fonts';

    export const globalStyles = StyleSheet.create({
      container: {
        flex: 1,
        padding: 20,
        backgroundColor: colors.primary,
      },
      text: {
        fontFamily: fonts.primary,
        color: '#fff',
      },
      button: {
        backgroundColor: colors.primary,
        padding: 10,
        borderRadius: 5,
      },
      buttonText: {
        fontFamily: fonts.primary,
        color: '#fff',
        textAlign: 'center',
      },
      // Add other styles here
    });
    ```

- **StyleSheet Creation:** Use `StyleSheet.create` for defining styles in React Native.

    ```tsx
    import { StyleSheet } from 'react-native';
    import { colors } from './styles/colors';

    const styles = StyleSheet.create({
      button: {
        backgroundColor: colors.primary,
        padding: 10,
        borderRadius: 5,
      },
      buttonText: {
        color: '#fff',
        textAlign: 'center',
      },
    });

    export default styles;
    ```

### Hooks

- **Reusable Hooks:** Store reusable hooks in the `app/hooks` directory.

    ```tsx
    // hooks/useFetchData.ts
    import { useState, useEffect } from 'react';

    const useFetchData = (url: string) => {
      const [data, setData] = useState(null);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        const fetchData = async () => {
          const response = await fetch(url);
          const result = await response.json();
          setData(result);
          setLoading(false);
        };

        fetchData();
      }, [url]);

      return { data, loading };
    };

    export default useFetchData;
    ```

## Conclusion

For any further assistance or questions, refer to the resources linked above or consult the official documentation of the respective libraries and frameworks.

Happy coding!


